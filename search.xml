<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Aggregate Function</title>
    <url>/2022/10/06/Aggregate-Function/</url>
    <content><![CDATA[<h3 id="入口函数-in-pkg-x2F-sql-x2F-sem-x2F-builtins-x2F-aggregate-builtins-go"><a href="#入口函数-in-pkg-x2F-sql-x2F-sem-x2F-builtins-x2F-aggregate-builtins-go" class="headerlink" title="入口函数 in pkg&#x2F;sql&#x2F;sem&#x2F;builtins&#x2F;aggregate_builtins.go"></a>入口函数 in pkg&#x2F;sql&#x2F;sem&#x2F;builtins&#x2F;aggregate_builtins.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> builtins</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initAggregateBuiltins</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add all aggregates to the builtins map after a few sanity checks.</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> aggregates &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v.props.Class != tree.AggregateClass &#123;</span><br><span class="line">            <span class="built_in">panic</span>(errors.AssertionFailedf(<span class="string">&quot;%s: aggregate functions should be marked with the tree.AggregateClass &quot;</span>+</span><br><span class="line"><span class="string">&quot;function class, found %v&quot;</span>, k, v))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> v.overloads &#123;</span><br><span class="line">            <span class="keyword">if</span> a.AggregateFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(errors.AssertionFailedf(<span class="string">&quot;%s: aggregate functions should have eval.AggregateFunc constructors, &quot;</span>+</span><br><span class="line"><span class="string">&quot;found %v&quot;</span>, k, a))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> a.WindowFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(errors.AssertionFailedf(<span class="string">&quot;%s: aggregate functions should have tree.WindowFunc constructors, &quot;</span>+</span><br><span class="line"><span class="string">&quot;found %v&quot;</span>, k, a))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        registerBuiltin(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// aggregates are a special class of builtin functions that are wrapped</span></span><br><span class="line"><span class="comment">// at execution in a bucketing layer to combine (aggregate) the result</span></span><br><span class="line"><span class="comment">// of the function being run over many rows.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See `aggregateFuncHolder` in the sql package.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In particular they must not be simplified during normalization</span></span><br><span class="line"><span class="comment">// (and thus must be marked as impure), even when they are given a</span></span><br><span class="line"><span class="comment">// constant argument (e.g. SUM(1)). This is because aggregate</span></span><br><span class="line"><span class="comment">// functions must return NULL when they are no rows in the source</span></span><br><span class="line"><span class="comment">// table, so their evaluation must always be delayed until query</span></span><br><span class="line"><span class="comment">// execution.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Some aggregate functions must be called with NULL inputs, so normalizing</span></span><br><span class="line"><span class="comment">// an aggregate function call to NULL in the presence of a NULL argument may</span></span><br><span class="line"><span class="comment">// not be correct. There are two cases where an aggregate function must handle</span></span><br><span class="line"><span class="comment">// be called with null inputs:</span></span><br><span class="line"><span class="comment">// 1) the aggregate function does not skip NULLs (e.g., ARRAY_AGG); and</span></span><br><span class="line"><span class="comment">// 2) the aggregate function does not return NULL when it aggregates no rows</span></span><br><span class="line"><span class="comment">//		(e.g., COUNT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For use in other packages, see AllAggregateBuiltinNames and</span></span><br><span class="line"><span class="comment">// GetBuiltinProperties().</span></span><br><span class="line"><span class="comment">// These functions are also identified with Class == tree.AggregateClass.</span></span><br><span class="line"><span class="comment">// The properties are reachable via tree.FunctionDefinition.</span></span><br><span class="line"><span class="keyword">var</span> aggregates = <span class="keyword">map</span>[<span class="type">string</span>]builtinDefinition&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="string">&quot;list_agg&quot;</span>: makeBuiltin(aggProps(),</span><br><span class="line">		makeAggOverload([]*types.T&#123;types.Any, types.Any&#125;, types.String, newListAggAggregate,</span><br><span class="line">			<span class="string">&quot;Concatenates all selected values using the provided delimiter.&quot;</span>, volatility.Immutable, <span class="literal">true</span> <span class="comment">/* calledOnNullInput */</span>),</span><br><span class="line">	),</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>crdb</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>Test Oracle Random</title>
    <url>/2022/08/01/Test-Oracle-Random/</url>
    <content><![CDATA[<h3 id="以下测试用例证明where后面的random函数每行数据都会跑一遍"><a href="#以下测试用例证明where后面的random函数每行数据都会跑一遍" class="headerlink" title="以下测试用例证明where后面的random函数每行数据都会跑一遍"></a>以下测试用例证明where后面的random函数每行数据都会跑一遍</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- pg  &amp; crdb</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tr1114(c1 <span class="type">int</span> ,c2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">select</span> generate_series(<span class="number">1</span>,<span class="number">10000</span>),generate_series(<span class="number">1</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1114 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>((random()<span class="operator">*</span><span class="number">10000</span>)<span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id2 <span class="operator">=</span> trunc(random()<span class="operator">*</span><span class="number">10</span>);</span><br><span class="line">id1 <span class="operator">|</span> id2</span><br><span class="line"><span class="comment">-----+-----</span></span><br><span class="line">   <span class="number">4</span> <span class="operator">|</span>   <span class="number">4</span></span><br><span class="line">   <span class="number">7</span> <span class="operator">|</span>   <span class="number">7</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id2 <span class="operator">=</span> trunc(random()<span class="operator">*</span><span class="number">10</span>);</span><br><span class="line">id1 <span class="operator">|</span> id2</span><br><span class="line"><span class="comment">-----+-----</span></span><br><span class="line">   <span class="number">6</span> <span class="operator">|</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">0</span> <span class="operator">|</span>   <span class="number">0</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id2 <span class="operator">=</span> trunc(random()<span class="operator">*</span><span class="number">10</span>);</span><br><span class="line">id1 <span class="operator">|</span> id2</span><br><span class="line"><span class="comment">-----+-----</span></span><br><span class="line">   <span class="number">5</span> <span class="operator">|</span>   <span class="number">5</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- oracle :</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tr1114(c1 <span class="type">int</span> ,c2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">7</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 创建一张大数据量的表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1 <span class="operator">+</span> <span class="number">1341</span>,tr1114.c2<span class="operator">+</span> <span class="number">5173</span> <span class="keyword">from</span> tr1114;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1 <span class="operator">+</span> <span class="number">1341</span>,tr1114.c2<span class="operator">+</span> <span class="number">5173</span> <span class="keyword">from</span> tr1114;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1 <span class="operator">+</span> <span class="number">116</span>,tr1114.c2<span class="operator">+</span> <span class="number">1273</span> <span class="keyword">from</span> tr1114;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1114 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1<span class="operator">*</span><span class="number">2</span>,tr1114.c2<span class="operator">*</span><span class="number">3</span> <span class="keyword">from</span> tr1114;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1114 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id2 <span class="operator">=</span> trunc(random()<span class="operator">*</span><span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1114 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">C1	   C2</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">       <span class="number">106</span>	  <span class="number">106</span></span><br><span class="line">       <span class="number">128</span>	  <span class="number">128</span></span><br><span class="line">      <span class="number">2112</span>	 <span class="number">2112</span></span><br><span class="line">      <span class="number">9856</span>	 <span class="number">9856</span></span><br></pre></td></tr></table></figure>

<h2 id="仍需验证oracle有主键索引存在时，oracle行为是否是先计算random值，再通过主键索引扫描全表查找是否有符合条件的数据。"><a href="#仍需验证oracle有主键索引存在时，oracle行为是否是先计算random值，再通过主键索引扫描全表查找是否有符合条件的数据。" class="headerlink" title="仍需验证oracle有主键索引存在时，oracle行为是否是先计算random值，再通过主键索引扫描全表查找是否有符合条件的数据。"></a>仍需验证oracle有主键索引存在时，oracle行为是否是先计算random值，再通过主键索引扫描全表查找是否有符合条件的数据。</h2><h3 id="若真的是这样呢，猜测开销会比一行数据对比一个random值大。"><a href="#若真的是这样呢，猜测开销会比一行数据对比一个random值大。" class="headerlink" title="若真的是这样呢，猜测开销会比一行数据对比一个random值大。"></a>若真的是这样呢，猜测开销会比一行数据对比一个random值大。</h3><h4 id="先为大表添加主键索引"><a href="#先为大表添加主键索引" class="headerlink" title="先为大表添加主键索引"></a>先为大表添加主键索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tr1114 modify(c1 <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tr1114 <span class="keyword">add</span> <span class="keyword">constraint</span> pk_tr1114_1 <span class="keyword">primary</span> key(c1);</span><br></pre></td></tr></table></figure>
<h4 id="表中有重复数据，修改主键失败"><a href="#表中有重复数据，修改主键失败" class="headerlink" title="表中有重复数据，修改主键失败"></a>表中有重复数据，修改主键失败</h4><p>tr1115  tr1116 数据量相同，tr1115主键为c1，tr1116无主键</p>
<h4 id="创建新表-tr1115-有主键，tr1116-无主键"><a href="#创建新表-tr1115-有主键，tr1116-无主键" class="headerlink" title="创建新表 tr1115 有主键，tr1116 无主键"></a>创建新表 tr1115 有主键，tr1116 无主键</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- tr1115 有主键</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tr1115;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tr1115(c1 <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,c2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1115 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1, tr1114.c1 <span class="operator">+</span> <span class="number">1</span> <span class="keyword">from</span> tr1114;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- tr1116 无主键</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tr1116;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tr1116(c1 <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,c2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tr1116 <span class="keyword">select</span> <span class="keyword">distinct</span> tr1114.c1, tr1114.c1 <span class="operator">+</span> <span class="number">1</span> <span class="keyword">from</span> tr1114;</span><br></pre></td></tr></table></figure>

<h4 id="查看执行计划，cost"><a href="#查看执行计划，cost" class="headerlink" title="查看执行计划，cost"></a>查看执行计划，cost</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span> traceonly;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1114 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">set</span> autotrace off;</span><br></pre></td></tr></table></figure>

<h3 id="有主键索引的表查询计划"><a href="#有主键索引的表查询计划" class="headerlink" title="有主键索引的表查询计划"></a>有主键索引的表查询计划</h3><h4 id="按照非主键扫描"><a href="#按照非主键扫描" class="headerlink" title="按照非主键扫描"></a>按照非主键扫描</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1115 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">Plan hash <span class="keyword">value</span>: <span class="number">1555111619</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id  <span class="operator">|</span> Operation	  <span class="operator">|</span> Name   <span class="operator">|</span> <span class="keyword">Rows</span>  <span class="operator">|</span> Bytes <span class="operator">|</span> Cost (<span class="operator">%</span>CPU)<span class="operator">|</span> <span class="type">Time</span>	   <span class="operator">|</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT  <span class="operator">|</span>	   <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	<span class="number">13</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span><span class="operator">|</span> TR1115 <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	<span class="number">13</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------------</span></span><br><span class="line">Predicate Information (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">---------------------------------------------------</span></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> <span class="keyword">filter</span>(&quot;C2&quot;<span class="operator">=</span><span class="built_in">CAST</span>(&quot;DBMS_RANDOM&quot;.&quot;VALUE&quot;()<span class="operator">*</span><span class="number">10000</span> <span class="keyword">AS</span> <span class="type">int</span>))</span><br><span class="line">Note</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">   <span class="operator">-</span> <span class="keyword">dynamic</span> statistics used: <span class="keyword">dynamic</span> sampling (level<span class="operator">=</span><span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="按照主键扫描"><a href="#按照主键扫描" class="headerlink" title="按照主键扫描"></a>按照主键扫描</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span>;</span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1115,tr1114 <span class="keyword">where</span> tr1115.c1<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>) <span class="keyword">and</span> tr1115.c1 <span class="operator">=</span> tr1114.c2;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">Plan hash <span class="keyword">value</span>: <span class="number">1128099595</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id  <span class="operator">|</span> Operation		    <span class="operator">|</span> Name	   <span class="operator">|</span> <span class="keyword">Rows</span>  <span class="operator">|</span> Bytes <span class="operator">|</span> Cost (<span class="operator">%</span>CPU)<span class="operator">|</span> <span class="type">Time</span>	   <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT	    <span class="operator">|</span>		   <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span>  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID<span class="operator">|</span> TR1115	   <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">2</span> <span class="operator">|</span>   INDEX <span class="keyword">UNIQUE</span> SCAN	    <span class="operator">|</span> SYS_C0010634 <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	   <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">Predicate Information (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">---------------------------------------------------</span></span><br><span class="line">   <span class="number">2</span> <span class="operator">-</span> access(&quot;C1&quot;<span class="operator">=</span><span class="built_in">CAST</span>(&quot;DBMS_RANDOM&quot;.&quot;VALUE&quot;()<span class="operator">*</span><span class="number">10000</span> <span class="keyword">AS</span> <span class="type">int</span>))</span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"></span><br><span class="line">        Statistics</span><br><span class="line"><span class="comment">----------------------------------------------------------</span></span><br><span class="line">	 <span class="number">25</span>  <span class="keyword">recursive</span> calls</span><br><span class="line">	  <span class="number">0</span>  db block gets</span><br><span class="line">	 <span class="number">10</span>  consistent gets</span><br><span class="line">	  <span class="number">0</span>  physical <span class="keyword">reads</span></span><br><span class="line">	  <span class="number">0</span>  redo size</span><br><span class="line">       <span class="number">1519</span>  bytes sent via <span class="keyword">SQL</span><span class="operator">*</span>Net <span class="keyword">to</span> client</span><br><span class="line">	<span class="number">403</span>  bytes received via <span class="keyword">SQL</span><span class="operator">*</span>Net <span class="keyword">from</span> client</span><br><span class="line">    <span class="number">2</span>  <span class="keyword">SQL</span><span class="operator">*</span>Net roundtrips <span class="keyword">to</span><span class="operator">/</span><span class="keyword">from</span> client</span><br><span class="line">            <span class="number">1</span>  sorts (memory)</span><br><span class="line">            <span class="number">0</span>  sorts (disk)</span><br><span class="line">            <span class="number">14</span>  <span class="keyword">rows</span> processed</span><br></pre></td></tr></table></figure>

<h4 id="按照主键扫描，filter条件中不使用random函数"><a href="#按照主键扫描，filter条件中不使用random函数" class="headerlink" title="按照主键扫描，filter条件中不使用random函数"></a>按照主键扫描，filter条件中不使用random函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span>;</span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1115 <span class="keyword">where</span> c1<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="operator">|</span> Id  <span class="operator">|</span> Operation		    <span class="operator">|</span> Name	   <span class="operator">|</span> <span class="keyword">Rows</span>  <span class="operator">|</span> Bytes <span class="operator">|</span> Cost (<span class="operator">%</span>CPU)<span class="operator">|</span> <span class="type">Time</span>	   <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT	    <span class="operator">|</span>		   <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span>  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID<span class="operator">|</span> TR1115	   <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	<span class="number">26</span> <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">2</span> <span class="operator">|</span>   INDEX <span class="keyword">UNIQUE</span> SCAN	    <span class="operator">|</span> SYS_C0010634 <span class="operator">|</span>	 <span class="number">1</span> <span class="operator">|</span>	   <span class="operator">|</span>	 <span class="number">1</span>   (<span class="number">0</span>) <span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">PLAN_TABLE_OUTPUT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">Predicate Information (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">---------------------------------------------------</span></span><br><span class="line">   <span class="number">2</span> <span class="operator">-</span> access(&quot;C1&quot;<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">Statistics</span><br><span class="line"><span class="comment">----------------------------------------------------------</span></span><br><span class="line">	 <span class="number">19</span>  <span class="keyword">recursive</span> calls</span><br><span class="line">	  <span class="number">0</span>  db block gets</span><br><span class="line">	 <span class="number">10</span>  consistent gets</span><br><span class="line">	  <span class="number">0</span>  physical <span class="keyword">reads</span></span><br><span class="line">	  <span class="number">0</span>  redo size</span><br><span class="line">       <span class="number">1478</span>  bytes sent via <span class="keyword">SQL</span><span class="operator">*</span>Net <span class="keyword">to</span> client</span><br><span class="line">	<span class="number">403</span>  bytes received via <span class="keyword">SQL</span><span class="operator">*</span>Net <span class="keyword">from</span> client</span><br><span class="line">    <span class="number">2</span>  <span class="keyword">SQL</span><span class="operator">*</span>Net roundtrips <span class="keyword">to</span><span class="operator">/</span><span class="keyword">from</span> client</span><br><span class="line">            <span class="number">1</span>  sorts (memory)</span><br><span class="line">            <span class="number">0</span>  sorts (disk)</span><br><span class="line">            <span class="number">14</span>  <span class="keyword">rows</span> processed</span><br></pre></td></tr></table></figure>

<h3 id="无主键索引的表查询计划"><a href="#无主键索引的表查询计划" class="headerlink" title="无主键索引的表查询计划"></a>无主键索引的表查询计划</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span>;</span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1116 <span class="keyword">where</span> c1<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br><span class="line"></span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tr1116 <span class="keyword">where</span> c2<span class="operator">=</span><span class="built_in">cast</span>(dbms_random.value<span class="operator">*</span><span class="number">10000</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> mosquito_t2;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mosquito_t2(</span><br><span class="line">c1 <span class="type">decimal</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">c2 <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">c3 <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">c4 <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">primary</span> key (c1)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> c1,c2,c3,c3 <span class="keyword">from</span> t2 <span class="keyword">where</span> c1<span class="operator">=</span>round(<span class="number">10000000</span><span class="operator">*</span>dbms_random.value);</span><br><span class="line"><span class="keyword">select</span> c1,c2,c3,c3 <span class="keyword">from</span> t2 <span class="keyword">where</span> c1<span class="operator">=</span>round(<span class="number">10000000</span><span class="operator">*</span>dbms_random.value) <span class="keyword">and</span> c1 <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">9888</span>);</span><br><span class="line"><span class="keyword">select</span> c1,c2,c3,c3 <span class="keyword">from</span> t2 <span class="keyword">where</span> c1<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span>;</span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> c1,c2,c3,c3 <span class="keyword">from</span> t2 <span class="keyword">where</span> c1<span class="operator">=</span>round(<span class="number">10000000</span><span class="operator">*</span>random());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>兼容oracle</category>
      </categories>
      <tags>
        <tag>function</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>crdb的float类型</title>
    <url>/2022/03/10/crdb%E7%9A%84float%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="float-类型"><a href="#float-类型" class="headerlink" title="float 类型"></a>float 类型</h2><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><h4 id="按照IEEE754国际标准"><a href="#按照IEEE754国际标准" class="headerlink" title="按照IEEE754国际标准"></a>按照IEEE754国际标准</h4><h4 id="oracle-中的-float-类型"><a href="#oracle-中的-float-类型" class="headerlink" title="oracle 中的 float 类型"></a>oracle 中的 float 类型</h4><ul>
<li>float</li>
<li>float(b)<ul>
<li>binary precision＝int(b*0.30103)，</li>
<li>因此我们这里实际上的精度应该等于int(2*0.30103)&#x3D;0，即小数点后精度为0。</li>
</ul>
</li>
</ul>
<h4 id="cockroachDB-中的-float-类型"><a href="#cockroachDB-中的-float-类型" class="headerlink" title="cockroachDB 中的 float 类型"></a>cockroachDB 中的 float 类型</h4><ul>
<li>float4(32)</li>
<li>float8(64)</li>
</ul>
<h4 id="mysql-中的-float-类型"><a href="#mysql-中的-float-类型" class="headerlink" title="mysql 中的 float 类型"></a>mysql 中的 float 类型</h4><ul>
<li>float</li>
<li>float(b)<ul>
<li>binary precision＝int(b*0.30103)，</li>
<li>因此我们这里实际上的精度应该等于int(2*0.30103)&#x3D;0，即小数点后精度为0。</li>
</ul>
</li>
</ul>
<h4 id="进位舍入标准"><a href="#进位舍入标准" class="headerlink" title="进位舍入标准"></a>进位舍入标准</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// RoundDown rounds toward 0; truncate.</span></span><br><span class="line">	RoundDown = <span class="string">&quot;down&quot;</span></span><br><span class="line">	<span class="comment">// RoundHalfUp rounds up if the digits are &gt;= 0.5.</span></span><br><span class="line">	RoundHalfUp = <span class="string">&quot;half_up&quot;</span></span><br><span class="line">	<span class="comment">// RoundHalfEven rounds up if the digits are &gt; 0.5. If the digits are equal</span></span><br><span class="line">	<span class="comment">// to 0.5, it rounds up if the previous digit is odd, always producing an</span></span><br><span class="line">	<span class="comment">// even digit.</span></span><br><span class="line">	RoundHalfEven = <span class="string">&quot;half_even&quot;</span></span><br><span class="line">	<span class="comment">// RoundCeiling towards +Inf: rounds up if digits are &gt; 0 and the number</span></span><br><span class="line">	<span class="comment">// is positive.</span></span><br><span class="line">	RoundCeiling = <span class="string">&quot;ceiling&quot;</span></span><br><span class="line">	<span class="comment">// RoundFloor towards -Inf: rounds up if digits are &gt; 0 and the number</span></span><br><span class="line">	<span class="comment">// is negative.</span></span><br><span class="line">	RoundFloor = <span class="string">&quot;floor&quot;</span></span><br><span class="line">	<span class="comment">// RoundHalfDown rounds up if the digits are &gt; 0.5.</span></span><br><span class="line">	RoundHalfDown = <span class="string">&quot;half_down&quot;</span></span><br><span class="line">	<span class="comment">// RoundUp rounds away from 0.</span></span><br><span class="line">	RoundUp = <span class="string">&quot;up&quot;</span></span><br><span class="line">	<span class="comment">// Round05Up rounds zero or five away from 0; same as round-up, except that</span></span><br><span class="line">	<span class="comment">// rounding up only occurs if the digit to be rounded up is 0 or 5.</span></span><br><span class="line">	Round05Up = <span class="string">&quot;05up&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>crdb 与mysql表现是一致的,采用国际标准。而oracle是传统四舍五入</li>
<li>国际标准 ： 向偶数舍入法（银行家舍入）</li>
<li>RoundHalfEven rounds up if the digits are &gt; 0.5. If the digits are equal to 0.5,<br>it rounds up if the previous digit is odd,<br>always producing an even digit.</li>
<li>如果digits &gt; 0.5(e.g. digits &#x3D; 0.51)，RoundHalfEven会向上取整。</li>
<li>如果数字等于0.5。如果前一个数字是奇数，它就向上舍入。 总是产生一个偶数数字。</li>
<li>例证：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat( round(<span class="built_in">cast</span>(<span class="number">0.125</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>),  <span class="string">&#x27;%&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.12%, oracle .13%</span></span><br><span class="line"><span class="keyword">select</span> concat( round(<span class="built_in">cast</span>(<span class="number">0.115</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>),  <span class="string">&#x27;%&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.12%, oracle .12%</span></span><br><span class="line"><span class="keyword">select</span> concat( round(<span class="built_in">cast</span>(<span class="number">0.1251</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>),  <span class="string">&#x27;%&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.13%, oracle .13%</span></span><br><span class="line"><span class="keyword">select</span> concat( round(<span class="built_in">cast</span>(<span class="number">0.1151</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>),  <span class="string">&#x27;%&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.12%, oracle .12%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">cast</span>(<span class="number">0.125</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>)<span class="operator">||</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">from</span> dual; <span class="comment">-- oracle .13%</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">cast</span>(<span class="number">0.115</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>)<span class="operator">||</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">from</span> dual; <span class="comment">-- oracle .12%</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">cast</span>(<span class="number">0.1251</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>)<span class="operator">||</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">from</span> dual; <span class="comment">-- oracle .13%</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">cast</span>(<span class="number">0.1151</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="number">2</span>)<span class="operator">||</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">from</span> dual; <span class="comment">-- oracle .12%</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="built_in">cast</span>(<span class="number">0.5</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="string">&#x27;9&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0, oracle 1</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="built_in">cast</span>(<span class="number">0.15</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="string">&#x27;9.9&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.1, oracle 0.2</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="built_in">cast</span>(<span class="number">0.25</span> <span class="keyword">as</span> <span class="type">float</span>),<span class="string">&#x27;9.9&#x27;</span>) <span class="keyword">from</span> dual; <span class="comment">-- mysql/crdb 0.2, oracle 0.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="golang中-float与string的相互转化"><a href="#golang中-float与string的相互转化" class="headerlink" title="golang中 float与string的相互转化"></a>golang中 float与string的相互转化</h2><h3 id="获得一个float转string-准确的方式"><a href="#获得一个float转string-准确的方式" class="headerlink" title="获得一个float转string 准确的方式"></a>获得一个float转string 准确的方式</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s = strconv.FormatFloat(value, <span class="string">&#x27;f&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<h3 id="float-gt-string"><a href="#float-gt-string" class="headerlink" title="float-&gt;string"></a>float-&gt;string</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormatFloat converts the floating-point number f to a string,</span></span><br><span class="line"><span class="comment">// according to the format fmt and precision prec. It rounds the</span></span><br><span class="line"><span class="comment">// result assuming that the original was obtained from a floating-point</span></span><br><span class="line"><span class="comment">// value of bitSize bits (32 for float32, 64 for float64).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The format fmt is one of</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27; (-ddddp±ddd, a binary exponent),</span></span><br><span class="line"><span class="comment">// &#x27;e&#x27; (-d.dddde±dd, a decimal exponent),</span></span><br><span class="line"><span class="comment">// &#x27;E&#x27; (-d.ddddE±dd, a decimal exponent),</span></span><br><span class="line"><span class="comment">// &#x27;f&#x27; (-ddd.dddd, no exponent),</span></span><br><span class="line"><span class="comment">// &#x27;g&#x27; (&#x27;e&#x27; for large exponents, &#x27;f&#x27; otherwise),</span></span><br><span class="line"><span class="comment">// &#x27;G&#x27; (&#x27;E&#x27; for large exponents, &#x27;f&#x27; otherwise),</span></span><br><span class="line"><span class="comment">// &#x27;x&#x27; (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or</span></span><br><span class="line"><span class="comment">// &#x27;X&#x27; (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The precision prec controls the number of digits (excluding the exponent)</span></span><br><span class="line"><span class="comment">// printed by the &#x27;e&#x27;, &#x27;E&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;G&#x27;, &#x27;x&#x27;, and &#x27;X&#x27; formats.</span></span><br><span class="line"><span class="comment">// For &#x27;e&#x27;, &#x27;E&#x27;, &#x27;f&#x27;, &#x27;x&#x27;, and &#x27;X&#x27;, it is the number of digits after the decimal point.</span></span><br><span class="line"><span class="comment">// For &#x27;g&#x27; and &#x27;G&#x27; it is the maximum number of significant digits (trailing</span></span><br><span class="line"><span class="comment">// zeros are removed).</span></span><br><span class="line"><span class="comment">// The special precision -1 uses the smallest number of digits</span></span><br><span class="line"><span class="comment">// necessary such that ParseFloat will return f exactly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(genericFtoa(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, max(prec+<span class="number">4</span>, <span class="number">24</span>)), f, fmt, prec, bitSize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-gt-float"><a href="#string-gt-float" class="headerlink" title="string-&gt;float"></a>string-&gt;float</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParseFloat converts the string s to a floating-point number</span></span><br><span class="line"><span class="comment">// with the precision specified by bitSize: 32 for float32, or 64 for float64.</span></span><br><span class="line"><span class="comment">// When bitSize=32, the result still has type float64, but it will be</span></span><br><span class="line"><span class="comment">// convertible to float32 without changing its value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ParseFloat accepts decimal and hexadecimal floating-point number syntax.</span></span><br><span class="line"><span class="comment">// If s is well-formed and near a valid floating-point number,</span></span><br><span class="line"><span class="comment">// ParseFloat returns the nearest floating-point number rounded</span></span><br><span class="line"><span class="comment">// using IEEE754 unbiased rounding.</span></span><br><span class="line"><span class="comment">// (Parsing a hexadecimal floating-point value only rounds when</span></span><br><span class="line"><span class="comment">// there are more bits in the hexadecimal representation than</span></span><br><span class="line"><span class="comment">// will fit in the mantissa.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The errors that ParseFloat returns have concrete type *NumError</span></span><br><span class="line"><span class="comment">// and include err.Num = s.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If s is syntactically well-formed but is more than 1/2 ULP</span></span><br><span class="line"><span class="comment">// away from the largest floating point number of the given size,</span></span><br><span class="line"><span class="comment">// ParseFloat returns f = ±Inf, err.Err = ErrRange.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ParseFloat recognizes the strings &quot;NaN&quot;, and the (possibly signed) strings &quot;Inf&quot; and &quot;Infinity&quot;</span></span><br><span class="line"><span class="comment">// as their respective special floating point values. It ignores case when matching.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	f, n, err := parseFloatPrefix(s, bitSize)</span><br><span class="line">	<span class="keyword">if</span> n != <span class="built_in">len</span>(s) &amp;&amp; (err == <span class="literal">nil</span> || err.(*NumError).Err != ErrSyntax) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, syntaxError(fnParseFloat, s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFloatPrefix</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> bitSize == <span class="number">32</span> &#123;</span><br><span class="line">		f, n, err := atof32(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(f), n, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> atof64(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>cockroachDB</category>
        <category>dataType</category>
      </categories>
      <tags>
        <tag>crdb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装 oracle</title>
    <url>/2021/12/06/docker-%E5%AE%89%E8%A3%85-oracle/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p><a href="https://betteryuan.top/article/2020/5/18/46.html">参考文章</a></p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><h4 id="拉取oracle的docker镜像"><a href="#拉取oracle的docker镜像" class="headerlink" title="拉取oracle的docker镜像"></a>拉取oracle的docker镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull sath89/oracle-12c</span><br><span class="line">sudo docker run -d --name oracle -p 8080:8080 -p 1521:1521 -v YOURPATH:/mnt -e TZ=Asia/Shanghai sath89/oracle-12c</span><br><span class="line">docker <span class="built_in">exec</span> -it YOURCERTAIINID /bin/bash</span><br></pre></td></tr></table></figure>
<h4 id="安装阿里docker源"><a href="#安装阿里docker源" class="headerlink" title="安装阿里docker源"></a>安装阿里docker源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://pee6w651.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="重启docker源"><a href="#重启docker源" class="headerlink" title="重启docker源"></a>重启docker源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="选择oracle版本"><a href="#选择oracle版本" class="headerlink" title="选择oracle版本"></a>选择oracle版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mosquito]<span class="comment"># docker pull sath89/oracle-12c</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from sath89/oracle-12c</span><br><span class="line">863735b9fd15: Pull complete </span><br><span class="line">4fbaa2f403df: Pull complete </span><br><span class="line">44be94a95984: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">b8bc6e8767ee: Pull complete </span><br><span class="line">c918da326197: Pull complete </span><br><span class="line">448e1619a038: Pull complete </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">faadd00cf98e: Downloading [=====================&gt;                             ]  1.214GB/2.768GBfaadd00cf98e: Pull complete </span><br><span class="line">fab7f453b7c6: Pull complete </span><br><span class="line">c98ac63d2108: Pull complete </span><br><span class="line">Digest: sha256:565e1ad83bafbc009be34e1aeb4ff0f03d12b069604438a565f5b6ab3ed0c896</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> sath89/oracle-12c:latest</span><br><span class="line">docker.io/sath89/oracle-12c:latest</span><br></pre></td></tr></table></figure>

<h3 id="运行docker"><a href="#运行docker" class="headerlink" title="运行docker"></a>运行docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mosquito]<span class="comment">#  docker run -d --name oracle -p 8080:8080 -p 1521:1521 -v YOURPATH:/mnt -e TZ=Asia/Shanghai sath89/oracle-12c 834e7053d824e744cf391ba03fac3534e4358dd32ce1d14befbedf81b99cafbd</span></span><br></pre></td></tr></table></figure>
<h3 id="进入容器登录"><a href="#进入容器登录" class="headerlink" title="进入容器登录"></a>进入容器登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost ~]$ docker <span class="built_in">exec</span> -it 834e7053d824e744cf391ba03fac3534e4358dd32ce1d14befbedf81b99cafbd  /bin/bash</span><br><span class="line">root@834e7053d824:/<span class="comment"># find / -name &quot;sqlplus&quot; </span></span><br><span class="line">/u01/app/oracle-product/12.1.0/xe/bin/sqlplus</span><br><span class="line">/u01/app/oracle-product/12.1.0/xe/sqlplus</span><br><span class="line">root@834e7053d824:/<span class="comment"># /u01/app/oracle-product/12.1.0/xe/bin/sqlplus / as sysdba</span></span><br><span class="line"></span><br><span class="line">username： system</span><br><span class="line">password： oracle</span><br></pre></td></tr></table></figure>

<h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@834e7053d824:/<span class="comment"># /u01/app/oracle-product/12.1.0/xe/bin/sqlplus USERNAME@USERPWD</span></span><br><span class="line">我的还未实验                 /u01/app/oracle-product/12.1.0/xe/bin/sqlplus system@oracle</span><br></pre></td></tr></table></figure>

<h3 id="再次使用时-操作"><a href="#再次使用时-操作" class="headerlink" title="再次使用时  操作"></a>再次使用时  操作</h3><p><a href="https://www.jianshu.com/p/b30021a421b8">一个网友的操作指南</a></p>
<h4 id="docker-启动-oracle"><a href="#docker-启动-oracle" class="headerlink" title="docker 启动 oracle"></a>docker 启动 oracle</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost ~]$ docker start oracle</span><br><span class="line">oracle</span><br><span class="line">For more details see su(1).</span><br></pre></td></tr></table></figure>
<h4 id="查看当前运行的容器"><a href="#查看当前运行的容器" class="headerlink" title="查看当前运行的容器"></a>查看当前运行的容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost ~]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">834e7053d824        sath89/oracle-12c   <span class="string">&quot;/entrypoint.sh &quot;</span>   2 weeks ago         Up 4 minutes        0.0.0.0:1521-&gt;1521/tcp, 0.0.0.0:8080-&gt;8080/tcp   oracle</span><br></pre></td></tr></table></figure>

<h4 id="进入已启动的oracle容器"><a href="#进入已启动的oracle容器" class="headerlink" title="进入已启动的oracle容器"></a>进入已启动的oracle容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost ~]$ docker <span class="built_in">exec</span> -it oracle bash</span><br></pre></td></tr></table></figure>
<h4 id="加载环境变量"><a href="#加载环境变量" class="headerlink" title="加载环境变量"></a>加载环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#source /home/oracle/.bash_profile</span></span><br></pre></td></tr></table></figure>

<h4 id="进入sqlplus"><a href="#进入sqlplus" class="headerlink" title="进入sqlplus"></a>进入sqlplus</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@834e7053d824:/<span class="comment"># sqlplus /nolog</span></span><br><span class="line">SQL*Plus: Release 12.1.0.2.0 Production on Sun Nov 1 10:40:58 2020</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2014, Oracle.  All rights reserved.</span><br></pre></td></tr></table></figure>

<h4 id="以sysdba角色登录sqlplus"><a href="#以sysdba角色登录sqlplus" class="headerlink" title="以sysdba角色登录sqlplus"></a>以sysdba角色登录sqlplus</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> conn sys<span class="operator">/</span>oracle <span class="keyword">as</span> sysdba</span><br><span class="line">Connected.</span><br></pre></td></tr></table></figure>

<h5 id="查看当前实例下的数据库"><a href="#查看当前实例下的数据库" class="headerlink" title="查看当前实例下的数据库"></a>查看当前实例下的数据库</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> name <span class="keyword">from</span> v$database;</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line"><span class="comment">---------</span></span><br><span class="line">XE</span><br></pre></td></tr></table></figure>

<h5 id="查看有多少个数据表"><a href="#查看有多少个数据表" class="headerlink" title="查看有多少个数据表"></a>查看有多少个数据表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> user_tables;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">      <span class="number">1249</span></span><br></pre></td></tr></table></figure>
<h4 id="退出sqlplus"><a href="#退出sqlplus" class="headerlink" title="退出sqlplus"></a>退出sqlplus</h4><p>exit</p>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>exit</p>
<h3 id="容器停用重启"><a href="#容器停用重启" class="headerlink" title="容器停用重启"></a>容器停用重启</h3><p>docker start container_ID</p>
<h3 id="停用正在运行的容器"><a href="#停用正在运行的容器" class="headerlink" title="停用正在运行的容器"></a>停用正在运行的容器</h3><p>docker stop container_ID</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github时出现的问题</title>
    <url>/2022/11/06/github%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><h3 id="一、github-密钥过期"><a href="#一、github-密钥过期" class="headerlink" title="一、github 密钥过期"></a>一、github 密钥过期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gnome-ssh-askpass:161204): Gtk-WARNING **: 10:59:43.256: cannot open display:</span><br><span class="line">error: unable to read askpass response from &#x27;/usr/libexec/openssh/gnome-ssh-askpass&#x27;</span><br><span class="line">Password for &#x27;https://mosquito2333@github.com&#x27;:</span><br><span class="line">git: &#x27;credential-wincred&#x27; is not a git command. See &#x27;git --help&#x27;.</span><br><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span><br><span class="line">fatal: Authentication failed for &#x27;https://github.com/mosquito2333/cockroach.git/&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="解决方法：生成自己的token"><a href="#解决方法：生成自己的token" class="headerlink" title="解决方法：生成自己的token"></a>解决方法：生成自己的token</h4><p>1、登陆自己的github账号，个人设置 setting<br>2、setting –&gt; developer setting –&gt; personal access tokens –&gt; generate new token(选项全选)<br>3、保存该token  xxxxxxx<br>4、git remote set-url origin <a href="https://xxxxxxx@github.com/mosquito2333/cockroach.git">https://xxxxxxx@github.com/mosquito2333/cockroach.git</a><br>git remote set-url slwcrdb <a href="https://xxxxxxx@github.com/mosquito2333/cockroach.git">https://xxxxxxx@github.com/mosquito2333/cockroach.git</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>how-to-choose-db-index-keys</title>
    <url>/2022/03/21/how-to-choose-db-index-keys/</url>
    <content><![CDATA[<h3 id="crdb官方blog"><a href="#crdb官方blog" class="headerlink" title="crdb官方blog"></a><a href="https://www.cockroachlabs.com/blog/how-to-choose-db-index-keys/">crdb官方blog</a></h3><h3 id="3-Basic-Rules-for-Choosing-Indexes"><a href="#3-Basic-Rules-for-Choosing-Indexes" class="headerlink" title="3 Basic Rules for Choosing Indexes"></a>3 Basic Rules for Choosing Indexes</h3><p>There are a few basic rules to keep in mind when choosing indexes for a database. A good index should have these three properties:</p>
<p>Usefulness: Speed up the execution of some queries (or enforce a constraint)<br>Clustering: Keep records that are likely to be accessed together near each other<br>Scattering: Keep records that are unlikely to be accessed together far apart</p>
<h4 id="Usefulness"><a href="#Usefulness" class="headerlink" title="Usefulness"></a>Usefulness</h4><p>The first rule is simply a reminder that indexes aren’t free, and if it’s not helping the application somehow you’re better off without it.<br>Each additional index makes all writes to the table slower, but they can make some reads much faster.<br>The best case for write performance is a table with a primary key but no secondary indexes.<br>The first secondary index has a high cost because it means any insert to the table becomes a distributed transaction, but the cost of each additional secondary index is smaller.<br>Do not let this scare you away from secondary indexes, however. They’re not free, but they have such a transformative impact on read performance that it’s nearly always worthwhile to ensure that every query you run has a suitable index.<br>Note that in CockroachDB it’s never helpful to remove the primary key. The database will create a hidden primary key for any table that doesn’t have one, and this hidden key cannot be used by any queries, so it’s always better to have a real primary key that you choose.<br>慎用索引，索引的目的是读的快，但是会导致写的慢。<br>最好的写性能的例子是一个有主键但是没有二级索引的表。<br>第一个二级索引的代价是很高的，因为它意味着任何对表的插入操作会变成一个分布式事务。但是每一个补充二级索引的代价是很小的。</p>
<h4 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h4><p>The second rule, clustering, is a little more subtle. When an application needs to load multiple records at once ( for example, due to a JOIN or the use of the IN operator), it’s best for performance if those records are near each other.<br>Originally, this advice came about to minimize the number of seeks that must be performed on spinning HDDs. In a distributed database like CockroachDB, the same guideline serves to minimize the number of network operations to access data remotely. For instance, in a social network news feed, most page views only need data from the current day. Organizing the data by time may provide the best data clustering and cache efficiency (or maybe not, as we’ll see below).<br>CockroachDB offers a few SQL extensions that can further improve data clustering, including storing indexes.</p>
<p>Scattering<br>The third rule, scattering, is in some sense the converse of the second: when similar records are near each other, different records naturally have to go somewhere else.<br>However, it’s not always the case that improving clustering also increases scattering. In the social network news feed example, organizing records by time maximizes clustering, but it also creates a hotspot because all the posts happening right now are trying to write to the same place. This is a severe limitation on the application’s ability to scale – if a hotspot like this exists, it’s not necessarily possible to serve more users by adding more nodes to a CockroachDB cluster. In practice, clustering and scattering are more often in tension with each other than they are mutually reinforcing.<br>Options for Selecting Unique IDs<br>If a table doesn’t have a natural primary key, you’ll probably want to synthesize some sort of unique identifier for each record. For this, you have a few options:</p>
]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>优化器</tag>
      </tags>
  </entry>
  <entry>
    <title>normalize代码解读</title>
    <url>/2022/01/09/normalize%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="normalize-代码解读"><a href="#normalize-代码解读" class="headerlink" title="normalize 代码解读"></a>normalize 代码解读</h3><h4 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost optgen]# pwd</span><br><span class="line">pkg/sql/opt/optgen</span><br><span class="line">[mosquito@localhost optgen]# ll *</span><br><span class="line">drwxr-xr-x 5 mosquito mosquito  49 May 11 17:35 cmd</span><br><span class="line">drwxr-xr-x 3 mosquito mosquito 146 May 11 17:35 exprgen</span><br><span class="line">drwxr-xr-x 4 mosquito mosquito 333 May 11 20:40 lang</span><br><span class="line"></span><br><span class="line">cmd:</span><br><span class="line">drwxr-xr-x 2 mosquito mosquito   78 May 11 17:35 langgen</span><br><span class="line">drwxr-xr-x 3 mosquito mosquito   76 May 11 17:35 optfmt</span><br><span class="line">drwxr-xr-x 3 mosquito mosquito 4096 May 11 17:35 optgen</span><br><span class="line"></span><br><span class="line">langgen:</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1621 May 11 17:35 BUILD.bazel</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 11432 May 11 17:35 exprs_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3404 May 11 17:35 main.go                  ---generate langgen binary</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   864 May 11 17:35 ops_gen.go</span><br><span class="line"></span><br><span class="line">optfmt:</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   724 May 11 17:35 BUILD.bazel</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 11208 May 11 17:35 main.go                  ---generate optfmt binary</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1886 May 11 17:35 main_test.go</span><br><span class="line">drwxr-xr-x 2 mosquito mosquito    96 May 11 19:50 testdata</span><br><span class="line"></span><br><span class="line">optgen:</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1108 May 11 17:35 BUILD.bazel</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4430 May 11 17:35 exec_explain_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4727 May 11 17:35 exec_factory_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3829 May 11 17:35 explorer_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 30222 May 11 17:35 exprs_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 18310 May 11 17:35 factory_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  6988 May 11 17:35 main.go                  ---generate optgen binary</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2084 May 11 17:35 main_test.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2462 May 11 17:35 match_writer.go     #write interface,支持写，缩进写，反缩进写</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 19825 May 11 17:35 metadata.go         #map: scalar-&gt;opt.scalar 将变量等转换成go可支持变变量</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4339 May 11 17:35 ops_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 37163 May 11 17:35 rule_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2019 May 11 17:35 rule_names_gen.go</span><br><span class="line">drwxr-xr-x 2 mosquito mosquito   160 May 11 17:35 testdata</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1025 May 11 17:35 uniquifier.go       #unique</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2704 May 11 17:35 utils.go            #expandFields,#-&gt;//,input-&gt;Input</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3613 May 11 17:35 validator.go        #check tag and field</span><br><span class="line"></span><br><span class="line">exprgen:</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1103 May 11 17:35 BUILD.bazel</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  7257 May 11 17:35 custom_funcs.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 10963 May 11 17:35 expr_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   891 May 11 17:35 expr_gen_test.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1763 May 11 17:35 parse_type.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  6183 May 11 17:35 private.go</span><br><span class="line">drwxr-xr-x 2 mosquito mosquito   124 May 11 17:35 testdata</span><br><span class="line">exprgen 说明：</span><br><span class="line">    mosquito@192.168.86.128:26257/test3&gt; prepare s2 as opt plan &#x27;select * from tc where a=1&#x27;;</span><br><span class="line">    ERROR: PREPARE AS OPT PLAN is a testing facility that should not be used directly</span><br><span class="line">测试使用，正常使用不支持。</span><br><span class="line"></span><br><span class="line">lang:</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2367 May 11 17:35 BUILD.bazel            ---compile,parser,scanner</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 22741 May 11 17:35 compiler.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3046 May 11 17:35 compiler_test.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  5534 May 11 17:35 data_type.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 19474 May 11 17:35 doc.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 10431 May 11 17:35 expr.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 26562 May 11 17:35 expr.og.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3306 May 11 17:35 lang.opt              ---提供基础结构，由langgen生成对应og.go文件</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   375 May 11 17:35 operator.og.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1459 May 11 17:35 operator_string.go    ---将枚举中数值输出转string输出，由go stringer生成</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 19509 May 11 17:35 parser.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1292 May 11 17:35 parser_test.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  9607 May 11 17:35 scanner.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2141 May 11 17:35 scanner_test.go</span><br><span class="line">drwxr-xr-x 5 mosquito mosquito    47 May 11 17:35 support</span><br><span class="line">drwxr-xr-x 2 mosquito mosquito    51 May 11 17:35 testdata</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1245 May 11 17:35 token_string.go</span><br></pre></td></tr></table></figure>

<h4 id="编译生成"><a href="#编译生成" class="headerlink" title="编译生成"></a>编译生成</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">optgen</span><br><span class="line">[mosquito@localhost cockroach]# make</span><br><span class="line">GOPATH set to /cockroachdb/cockroach-master</span><br><span class="line">mkdir -p lib</span><br><span class="line">rm -f lib/lib&#123;geos,geos_c&#125;.so</span><br><span class="line">cp -L /cockroachdb/cockroach-master/native/x86_64-redhat-linux/geos/lib/lib&#123;geos,geos_c&#125;.so lib</span><br><span class="line">go install -v optgen</span><br><span class="line">GOFLAGS= bin/prereqs ./pkg/sql/opt/optgen/cmd/optgen &gt; bin/optgen.d.tmp</span><br><span class="line">./build/bazelutil/generate_redact_safe.sh &gt;docs/generated/redact_safe.md.tmp || &#123; rm -f docs/generated/redact_safe.md.tmp; exit 1; &#125;</span><br><span class="line">mv -f bin/optgen.d.tmp bin/optgen.d</span><br><span class="line">GOBIN=&#x27;/cockroachdb/cockroach-master/src/github.com/cockroachdb/cockroach/bin&#x27; </span><br><span class="line">GOFLAGS= go install -ldflags &#x27;-X github.com/cockroachdb/cockroach/pkg/build.typ=development -extldflags &quot;&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.tag=v9.0.0-rc.6.xTP-1-gf7ea2a4ea9-dirty&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.rev=f7ea2a4ea9a5253d2872563cd3b8d972c3a166a6&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.cgoTargetTriple=x86_64-redhat-linux&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.utcTime=2022/05/12 00:34:01&quot;   -X &quot;github.com/cockroachdb/cockroach/pkg/build.utcTime=2022/05/12 00:34:01&quot;&#x27; -v ./pkg/sql/opt/optgen/cmd/optgen</span><br><span class="line">optgen -out pkg/sql/opt/memo/expr.og.go exprs pkg/sql/opt/ops/*.opt</span><br><span class="line">optgen -out pkg/sql/opt/operator.og.go ops pkg/sql/opt/ops/*.opt</span><br><span class="line">optgen -out pkg/sql/opt/xform/explorer.og.go explorer pkg/sql/opt/ops/*.opt pkg/sql/opt/xform/rules/*.opt</span><br><span class="line">optgen -out pkg/sql/opt/norm/factory.og.go factory pkg/sql/opt/ops/*.opt pkg/sql/opt/norm/rules/*.opt</span><br><span class="line">optgen -out pkg/sql/opt/rule_name.og.go rulenames pkg/sql/opt/ops/*.opt pkg/sql/opt/norm/rules/*.opt pkg/sql/opt/xform/rules/*.opt</span><br><span class="line">optgen -out pkg/sql/opt/exec/factory.og.go execfactory pkg/sql/opt/exec/factory.opt</span><br><span class="line">optgen -out pkg/sql/opt/exec/explain/explain_factory.og.go execexplain pkg/sql/opt/exec/factory.opt</span><br><span class="line">stringer -output=pkg/sql/opt/rule_name_string.go -type=RuleName pkg/sql/opt/rule_name.go pkg/sql/opt/rule_name.og.go</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">langgen</span><br><span class="line">[mosquito@localhost cockroach]# make generate</span><br><span class="line">GOPATH set to /cockroachdb/cockroach-master</span><br><span class="line">mkdir -p lib</span><br><span class="line">rm -f lib/lib&#123;geos,geos_c&#125;.so</span><br><span class="line">cp -L /cockroachdb/cockroach-master/native/x86_64-redhat-linux/geos/lib/lib&#123;geos,geos_c&#125;.so lib</span><br><span class="line">go install -v langgen</span><br><span class="line">GOFLAGS= bin/prereqs ./pkg/sql/opt/optgen/cmd/langgen &gt; bin/langgen.d.tmp</span><br><span class="line">mv -f bin/langgen.d.tmp bin/langgen.d</span><br><span class="line">GOBIN=&#x27;/cockroachdb/cockroach-master/src/github.com/cockroachdb/cockroach/bin&#x27; GOFLAGS= go install -ldflags &#x27;-X github.com/cockroachdb/cockroach/pkg/build.typ=development -extldflags &quot;&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.tag=v9.0.0-rc.6.xTP-1-gf7ea2a4ea9-dirty&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.rev=f7ea2a4ea9a5253d2872563cd3b8d972c3a166a6&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.cgoTargetTriple=x86_64-redhat-linux&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.utcTime=2022/05/12 03:22:49&quot;  &#x27; -v ./pkg/sql/opt/optgen/cmd/langgen</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">optfmt</span><br><span class="line">[mosquito@localhost cockroach]# make lintshort</span><br><span class="line">GOPATH set to /cockroachdb/cockroach-master</span><br><span class="line">go install -v optfmt</span><br><span class="line">GOFLAGS= bin/prereqs ./pkg/sql/opt/optgen/cmd/optfmt &gt; bin/optfmt.d.tmp</span><br><span class="line">mkdir -p lib</span><br><span class="line">rm -f lib/lib&#123;geos,geos_c&#125;.so</span><br><span class="line">mv -f bin/optfmt.d.tmp bin/optfmt.d</span><br><span class="line">GOFLAGS= bin/prereqs ./pkg/sql/opt/optgen/cmd/optgen &gt; bin/optgen.d.tmp</span><br><span class="line">GOBIN=&#x27;/cockroachdb/cockroach-master/src/github.com/cockroachdb/cockroach/bin&#x27; GOFLAGS= go install -ldflags &#x27;-X github.com/cockroachdb/cockroach/pkg/build.typ=development -extldflags &quot;&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.tag=v9.0.0-rc.6.xTP-1-gf7ea2a4ea9-dirty&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.rev=f7ea2a4ea9a5253d2872563cd3b8d972c3a166a6&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.cgoTargetTriple=x86_64-redhat-linux&quot; -X &quot;github.com/cockroachdb/cockroach/pkg/build.utcTime=2022/05/12 03:37:17&quot;  &#x27; -v ./pkg/sql/opt/optgen/cmd/optfmt</span><br></pre></td></tr></table></figure>

<h4 id="二进制程序"><a href="#二进制程序" class="headerlink" title="二进制程序"></a>二进制程序</h4><p>编译完成后，生成对应三个二进制：optfmt，langgen，optgen。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GOBIN=&#x27;/cockroachdb/cockroach-master/src/github.com/cockroachdb/cockroach/bin&#x27;</span><br><span class="line">-rwxr-xr-x 1 mosquito mosquito 8586008 May 10 19:52 optfmt</span><br><span class="line">-rwxr-xr-x 1 mosquito mosquito 9395278 May 11 17:34 optgen</span><br><span class="line">-rwxr-xr-x 1 mosquito mosquito 9111178 May 10 20:47 langgen</span><br></pre></td></tr></table></figure>

<h5 id="langgen"><a href="#langgen" class="headerlink" title="langgen"></a>langgen</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost bin]# .langgen -h</span><br><span class="line">LangGen generates the AST for the Optgen language.</span><br><span class="line"></span><br><span class="line">LangGen uses the Optgen definition language to generate its own AST.</span><br><span class="line">Usage:</span><br><span class="line">        langgen [flags] command sources...</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        exprs  generate expression definitions and functions</span><br><span class="line">        ops    generate operator definitions and functions</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -out string</span><br><span class="line">        output file name of generated code</span><br><span class="line"></span><br><span class="line">//go:generate langgen -out expr.og.go exprs lang.opt</span><br><span class="line">//go:generate langgen -out operator.og.go ops lang.opt</span><br><span class="line">//go:generate stringer -type=Operator operator.og.go</span><br><span class="line"></span><br><span class="line">为compiler，parser等提供基础数据结构和基本操作方法。</span><br><span class="line">make generate引入。</span><br><span class="line">说明：</span><br><span class="line">1. 在make前，expr.og.go等文件必须存在，否则针对opt文件编译解析报错。</span><br></pre></td></tr></table></figure>

<h5 id="optfmt"><a href="#optfmt" class="headerlink" title="optfmt"></a>optfmt</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost bin]# ./optfmt -h</span><br><span class="line">usage of ./optfmt [flags] [path ...]:</span><br><span class="line">  -e    format an exprgen expression</span><br><span class="line">  -l    list diffs when formatting differs from optfmt&#x27;s</span><br><span class="line">  -verify</span><br><span class="line">        verify output order</span><br><span class="line">  -w    write result to (source) file instead of stdout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用于代码格式检查等。</span><br><span class="line">make lintshort引入。</span><br><span class="line">说明：</span><br><span class="line">1. 对代码格式检查时，可以执行make lintshort命令；或者直接使用optfmt命令</span><br></pre></td></tr></table></figure>

<h5 id="optgen"><a href="#optgen" class="headerlink" title="optgen"></a>optgen</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mosquito@localhost bin]# ./optgen -h</span><br><span class="line">Optgen is a tool for generating cost-based optimizers.</span><br><span class="line"></span><br><span class="line">It compiles source files that use a custom syntax to define expressions,</span><br><span class="line">match expression patterns, and generate replacement expressions.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">        optgen [flags] command sources...</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        compile    generate the optgen compiled format</span><br><span class="line">        explorer   generate expression tree exploration rules</span><br><span class="line">        exprs      generate expression definitions and functions</span><br><span class="line">        factory    generate expression tree creation and normalization functions</span><br><span class="line">        ops        generate operator definitions and functions</span><br><span class="line">        rulenames  generate enumeration of rule names</span><br><span class="line"></span><br><span class="line">The sources can be file names and/or filepath.Glob patterns.</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -out string</span><br><span class="line">        output file name of generated code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过commands参数将sources（*.opt）编译解析生成运行时所需的og文件。</span><br></pre></td></tr></table></figure>

<h4 id="optgen-1"><a href="#optgen-1" class="headerlink" title="optgen"></a>optgen</h4><h5 id="Optgen"><a href="#Optgen" class="headerlink" title="Optgen"></a>Optgen</h5><p> 参考资料：pkg&#x2F;sql&#x2F;opt&#x2F;optgen&#x2F;lang&#x2F;doc.go。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Package lang implements a language called Optgen, short for &quot;optimizer generator&quot;. Optgen is a domain-specific language (DSL) that provides an intuitive syntax for defining, matching, and replacing nodes in a target expression tree.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Here is the syntax for an operator definition:</span><br><span class="line"></span><br><span class="line">  define &lt;name&gt; &#123;</span><br><span class="line">    &lt;field-1-name&gt; &lt;field-1-type&gt;</span><br><span class="line">    &lt;field-2-name&gt; &lt;field-2-type&gt;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Here is the definition tagging syntax:</span><br><span class="line"></span><br><span class="line">  [&lt;tag-1-name&gt;, &lt;tag-2-name&gt;, ...]</span><br><span class="line">  define &lt;name&gt; &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Here is the partial rule syntax (see Syntax section for full syntax):</span><br><span class="line"></span><br><span class="line">  [&lt;rule-name&gt;, &lt;tag-1-name&gt;, &lt;tag-2-name&gt;, ...]</span><br><span class="line">  (&lt;match-opname&gt;</span><br><span class="line">    &lt;match-expr&gt;</span><br><span class="line">    &lt;match-expr&gt;</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">  =&gt;</span><br><span class="line">  (&lt;replace-opname&gt;</span><br><span class="line">    &lt;replace-expr&gt;</span><br><span class="line">    &lt;replace-expr&gt;</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Syntax</span><br><span class="line"></span><br><span class="line">This section describes the Optgen language syntax in a variant of extended</span><br><span class="line">Backus-Naur form. The non-terminals correspond to methods in the parser. The</span><br><span class="line">terminals correspond to tokens returned by the scanner. Whitespace and</span><br><span class="line">comment tokens can be freely interleaved between other tokens in the</span><br><span class="line">grammar.</span><br><span class="line"></span><br><span class="line">  root         = tags (define | rule)</span><br><span class="line">  tags         = &#x27;[&#x27; IDENT (&#x27;,&#x27; IDENT)* &#x27;]&#x27;</span><br><span class="line"></span><br><span class="line">  define       = &#x27;define&#x27; define-name &#x27;&#123;&#x27; define-field* &#x27;&#125;&#x27;</span><br><span class="line">  define-name  = IDENT</span><br><span class="line">  define-field = field-name field-type</span><br><span class="line">  field-name   = IDENT</span><br><span class="line">  field-type   = IDENT</span><br><span class="line"></span><br><span class="line">  rule         = func &#x27;=&gt;&#x27; replace</span><br><span class="line">  match        = func</span><br><span class="line">  replace      = func | ref</span><br><span class="line">  func         = &#x27;(&#x27; func-name arg* &#x27;)&#x27;</span><br><span class="line">  func-name    = names | func</span><br><span class="line">  names        = name (&#x27;|&#x27; name)*</span><br><span class="line">  arg          = bind and | ref | and</span><br><span class="line">  and          = expr (&#x27;&amp;&#x27; and)</span><br><span class="line">  expr         = func | not | let | list | any | name | STRING | NUMBER</span><br><span class="line">  not          = &#x27;^&#x27; expr</span><br><span class="line">  list         = &#x27;[&#x27; list-child* &#x27;]&#x27;</span><br><span class="line">  list-child   = list-any | arg</span><br><span class="line">  list-any     = &#x27;...&#x27;</span><br><span class="line">  bind         = &#x27;$&#x27; label &#x27;:&#x27; and</span><br><span class="line">  let          = &#x27;(&#x27; &#x27;Let&#x27; &#x27;(&#x27; &#x27;$&#x27; label (&#x27;$&#x27; label)* &#x27;)&#x27; &#x27;:&#x27; func ref &#x27;)&#x27;</span><br><span class="line">  ref          = &#x27;$&#x27; label</span><br><span class="line">  any          = &#x27;*&#x27;</span><br><span class="line">  name         = IDENT</span><br><span class="line">  label        = IDENT</span><br><span class="line"></span><br><span class="line">Here are the pseudo-regex definitions for the lexical tokens that aren&#x27;t represented as single-quoted strings above:</span><br><span class="line"></span><br><span class="line">  STRING     = &quot; [^&quot;\n]* &quot;</span><br><span class="line">  NUMBER     = UnicodeDigit+</span><br><span class="line">  IDENT      = (UnicodeLetter | &#x27;_&#x27;) (UnicodeLetter | &#x27;_&#x27; | UnicodeNumber)*</span><br><span class="line">  COMMENT    = &#x27;#&#x27; .* \n</span><br><span class="line">  WHITESPACE = UnicodeSpace+</span><br><span class="line"></span><br><span class="line">The support directory contains syntax coloring files for several editors,</span><br><span class="line">including Vim, TextMate, and Visual Studio Code. JetBrains editor (i.e. GoLand)</span><br><span class="line">can also import TextMate bundles to provide syntax coloring.</span><br><span class="line"></span><br><span class="line">Components</span><br><span class="line"></span><br><span class="line">The lang package contains a scanner that breaks input files into lexical</span><br><span class="line">tokens, a parser that assembles an abstract syntax tree (AST) from the tokens,</span><br><span class="line">and a compiler that performs semantic checks and creates a rudimentary symbol</span><br><span class="line">table.</span><br><span class="line"></span><br><span class="line">The compiled rules and definitions become the input to a separate code</span><br><span class="line">generation package which generates parts of the Cockroach DB SQL optimizer.</span><br><span class="line">However, the Optgen language itself is not Cockroach or SQL specific, and can</span><br><span class="line">be used in other contexts. For example, the Optgen language parser generates</span><br><span class="line">its own AST expressions using itself (compiler bootstrapping).</span><br></pre></td></tr></table></figure>

<h5 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h5><p> *.opt contains the set of definitions and rules which from the Optgen input files.</p>
<p>compile：</p>
<p> *.opt  ——&gt; compile &lt;—-&gt;  parse  &lt;——-&gt; scanner </p>
<p>scan：</p>
<p>files(3) : sort(files) : file1—-&gt;file1_lines—-&gt;end—&gt;file2—–&gt;file2_lines—–&gt;end—-&gt;file3—-&gt;file3_lines—-&gt;end.</p>
<h5 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h5><p>主要文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg/sql/opt/optgen/lang</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 22741 May 11 20:40 compiler.go   ---编译</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 19509 May 11 20:40 parser.go     ---解析</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  9607 May 11 20:40 scanner.go    ---扫描</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkg/sql/opt/optgen/cmd/optgen</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4430 May 11 17:35 exec_explain_gen.go     ---不同generate实现</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4727 May 11 17:35 exec_factory_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3829 May 11 17:35 explorer_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 30222 May 11 17:35 exprs_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 18310 May 11 17:35 factory_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4339 May 11 17:35 ops_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 37163 May 11 17:35 rule_gen.go</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2019 May 11 17:35 rule_names_gen.go</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  6988 May 12 18:35 main.go                 ---主函数，入口</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2462 May 11 17:35 match_writer.go         ---写接口：提供缩进写，写，反缩进写</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 19825 May 11 17:35 metadata.go             ---map：将opt中define，name等转go code</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1025 May 11 17:35 uniquifier.go           ---unique</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2704 May 11 17:35 utils.go                ---大小写转换，扩展fields，#转//</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3613 May 11 17:35 validator.go            ---check tag &amp; field</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[CommuteVarInequality, Normalize]</span><br><span class="line">(Le | Lt | Ge | Gt $left:^(Variable) $right:(Variable))</span><br><span class="line">=&gt;</span><br><span class="line">(CommuteInequality (OpName) $left $right)</span><br><span class="line"><span class="meta prompt_">---&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">RuleExpr&#123;</span></span><br><span class="line">        Src:      &amp;src,                    -----&gt;rule所在file以及line和pos,参考说明</span><br><span class="line">        Name:     StringExpr(tags[0]),     -----&gt;rule Name</span><br><span class="line">        Comments: comments,                -----&gt;rule Comment</span><br><span class="line">        Tags:     tags[1:],                -----&gt;tags exclude tag[0](rule name)</span><br><span class="line">        Match:    match.(*FuncExpr),       -----&gt;old rule(maybe multiplt)</span><br><span class="line">        Replace:  replace,                 -----&gt;new rule</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1. Match可能会包含多个define（如上Le|Lt|Ge|Gt）,在compile会进一步对match做expandRule</span><br><span class="line">2. Src用于错误输出，如：</span><br><span class="line">    pkg/sql/opt/norm/factory.og.go:13305:56: not enough arguments in call to _f.ConstructLe</span><br><span class="line"></span><br><span class="line">rule详细介绍：</span><br><span class="line">规则模板：</span><br><span class="line">[&lt;rule-name&gt;, &lt;tag-1-name&gt;, &lt;tag-2-name&gt;, ...]</span><br><span class="line">(&lt;match-opname&gt;</span><br><span class="line">    &lt;match-expr&gt;</span><br><span class="line">    &lt;match-expr&gt;</span><br><span class="line">    ...</span><br><span class="line"> )</span><br><span class="line"> =&gt;</span><br><span class="line"> (&lt;replace-opname&gt;</span><br><span class="line">   &lt;replace-expr&gt;</span><br><span class="line">   &lt;replace-expr&gt;</span><br><span class="line">   ...</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">对于现有xtp的优化规则有两种：normalize和explorer</span><br><span class="line">rule_name: 规则名称</span><br><span class="line">tag-1-name: 区分规则-&gt;(Normalize-&gt;RBO,Explorer-&gt;CBO)</span><br><span class="line">tag-2-name: 优先级-&gt;(HighPriority和LowPriority)  表示执行顺序，优先级高先执行</span><br><span class="line">tag-*-name: 暂无</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1. tags是等价的，无先后之分，只要提供对应tag即可。</span><br><span class="line">2. 在生成规则的时候，通过tag：Normalize和Explorer判断需要生成对应的规则。</span><br><span class="line"></span><br><span class="line">样例如下：</span><br><span class="line">[SimplifySelectFilters, Normalize, HighPriority]</span><br><span class="line">(Select</span><br><span class="line">    $input:*</span><br><span class="line">    $filters:[</span><br><span class="line">            ...</span><br><span class="line">            $item:(FiltersItem</span><br><span class="line">                    (And | True | False | Null | Or | Is)</span><br><span class="line">                ) &amp;</span><br><span class="line">                ^(IsUnsimplifiableOr $item) &amp;</span><br><span class="line">                ^(IsUnsimplifiableIs $item)</span><br><span class="line">            ...</span><br><span class="line">        ] &amp;</span><br><span class="line">        ^(IsFilterFalse $filters)</span><br><span class="line">)</span><br><span class="line">=&gt;</span><br><span class="line">(Select $input (SimplifyFilters $filters))</span><br><span class="line"></span><br><span class="line">[GenerateZigzagJoins, Explore]</span><br><span class="line">(Select</span><br><span class="line">    (Scan $scan:*) &amp; (IsCanonicalScan $scan) &amp; ^(IsLocking $scan)</span><br><span class="line">    $filters:*</span><br><span class="line">)</span><br><span class="line">=&gt;</span><br><span class="line">(GenerateZigzagJoins $scan $filters)</span><br><span class="line"></span><br><span class="line">match-opname： 对应define 由*.opt提供，并通过optgen编译解析生成对应结构体</span><br><span class="line">match-expr：对应define所包含的fields，即结构体成员</span><br><span class="line"></span><br><span class="line">replace-opname：同match-opname</span><br><span class="line">replace-expr：同match-expr</span><br><span class="line"></span><br><span class="line">match-expr和replace-expr不能超过定义的数量，否则报错，如下：</span><br><span class="line">comp.opt:9:1: Lt has only 2 fields</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LookupJoin represents a <span class="built_in">join</span> between an input expression and an index. The</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span> of <span class="built_in">join</span> is <span class="keyword">in</span> the LookupJoinPrivate field.</span></span><br><span class="line">[Relational]</span><br><span class="line">define LookupJoin &#123;</span><br><span class="line">    Input RelExpr</span><br><span class="line">    On FiltersExpr</span><br><span class="line">    _ LookupJoinPrivate</span><br><span class="line"></span><br><span class="line">    # lookupProps caches relational properties for the &quot;table&quot; side of the lookup</span><br><span class="line">    # join, treating it as if it were another relational input. This makes the</span><br><span class="line">    # lookup join appear more like other join operators.</span><br><span class="line">    lookupProps RelProps</span><br><span class="line">&#125;</span><br><span class="line">=====》</span><br><span class="line">// LookupJoinExpr represents a join between an input expression and an index. The</span><br><span class="line">// type of join is in the LookupJoinPrivate field.</span><br><span class="line">type LookupJoinExpr struct &#123;</span><br><span class="line">    Input RelExpr</span><br><span class="line">    On    FiltersExpr</span><br><span class="line">    LookupJoinPrivate</span><br><span class="line"></span><br><span class="line">    // lookupProps caches relational properties for the &quot;table&quot; side of the lookup</span><br><span class="line">    // join, treating it as if it were another relational input. This makes the</span><br><span class="line">    // lookup join appear more like other join operators.</span><br><span class="line">    lookupProps props.Relational</span><br><span class="line"></span><br><span class="line">    grp  exprGroup</span><br><span class="line">    next RelExpr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="define"><a href="#define" class="headerlink" title="define"></a>define</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Scalar, Bool, Comparison, CompositeInsensitive]</span><br><span class="line">define Lt &#123;</span><br><span class="line">    Left SclarExpr</span><br><span class="line">    Right ScalarExpr</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">---&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">DefineExpr&#123;</span></span><br><span class="line">                Src:       &amp;src,               -----&gt;define所在file以及line和pos</span><br><span class="line">                Comments:  comments,           -----&gt;define Comment</span><br><span class="line">                Name:      StringExpr(name),   -----&gt;define Name</span><br><span class="line">                Tags:      tags,               -----&gt;tags all</span><br><span class="line">                Fields：   fields,             -----&gt;define fields</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define详细介绍：</span><br><span class="line">规则模板：  </span><br><span class="line">[&lt;tag-1-name&gt;, &lt;tag-2-name&gt;, ...]</span><br><span class="line">  define &lt;name&gt; &#123;</span><br><span class="line">    &lt;field-1-name&gt; &lt;field-1-type&gt;</span><br><span class="line">    &lt;field-2-name&gt; &lt;field-2-type&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">与rule规则有所区别，[]只有tag,不同的gen可以根据tag来选择是否需要增加和go转换。</span><br><span class="line">define: 关键字，表示结构体</span><br><span class="line">name: 结构体名称，不过在go转换的时候，name可能发生变化，如scalar---&gt;scalarExpr</span><br><span class="line">field-1-name: 成员名称</span><br><span class="line">field-1-type: 成员类型</span><br></pre></td></tr></table></figure>

<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">compile格式：</span><br><span class="line">[mosquito@localhost bin]# ./optgen -out log  compile  pkg/sql/opt/optgen/lang/lang.opt</span><br><span class="line">[mosquito@localhost bin]# cat log</span><br><span class="line">(Compiled</span><br><span class="line">        (Defines</span><br><span class="line">        )</span><br><span class="line">        (Rules</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">将解析后的rules和defines编译检查</span><br><span class="line">// Compile parses and compiles the input files and returns the resulting</span><br><span class="line">// CompiledExpr. If there are errors, then Compile returns nil, and the errors</span><br><span class="line">// are returned by the Errors function.</span><br><span class="line">func (c *Compiler) Compile() *CompiledExpr &#123;</span><br><span class="line">    mosquito := c.parser.Parse()                         ---&gt;解析和扫描opt文件</span><br><span class="line">    if mosquito == nil &#123;</span><br><span class="line">        c.errors = c.parser.Errors()</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if !c.compileDefines(mosquito.Defines) &#123;             ---&gt;处理defines</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if !c.compileRules(mosquito.Rules) &#123;                 ---&gt;处理rules</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return c.compiled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CompiledExpr is the result of Optgen scanning, parsing, and semantic</span><br><span class="line">// analysis. It contains the set of definitions and rules that were compiled</span><br><span class="line">// from the Optgen input files.</span><br><span class="line">type CompiledExpr struct &#123;</span><br><span class="line">    Defines     DefineSetExpr                   ---&gt;解析后的defines</span><br><span class="line">    Rules       RuleSetExpr                     ---&gt;解析后的rules</span><br><span class="line">    DefineTags  []string                        ---&gt;解析后的defines&#x27; tags</span><br><span class="line">    defineIndex map[string]*DefineExpr          ---&gt;map define.name——&gt;define</span><br><span class="line">    matchIndex  map[string]RuleSetExpr          ---&gt;map define.name——&gt;rule(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将解析后的defines和rules填充到CompiledExpr结构中，为后面所有的generate提供源。</span><br></pre></td></tr></table></figure>

<h5 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg/sql/opt/optgen/cmd/optgen/main.go</span><br><span class="line"></span><br><span class="line">func (g *optgen) run(args ...string) bool &#123;</span><br><span class="line">...</span><br><span class="line">// Sort the files so that output is stable.</span><br><span class="line">sort.Strings(files)</span><br><span class="line"></span><br><span class="line">compiler := lang.NewCompiler(files...)</span><br><span class="line">...</span><br><span class="line">compiled := compiler.Compile()                       ------compiled作为入参</span><br><span class="line">...</span><br><span class="line">switch cmd &#123;</span><br><span class="line">case &quot;compile&quot;:</span><br><span class="line">    err = g.writeOutputFile([]byte(compiled.String()))</span><br><span class="line">case &quot;explorer&quot;:</span><br><span class="line">    var gen explorerGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;exprs&quot;:</span><br><span class="line">    var gen exprsGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;factory&quot;:</span><br><span class="line">    var gen factoryGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;ops&quot;:</span><br><span class="line">    var gen opsGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;rulenames&quot;:</span><br><span class="line">    var gen ruleNamesGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;execfactory&quot;:</span><br><span class="line">    var gen execFactoryGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">case &quot;execexplain&quot;:</span><br><span class="line">    var gen execExplainGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p> 1. rule-&gt;变量交换位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CommuteVarInequality is similar to CommuteVar (<span class="keyword">in</span> scalar.opt), except it</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">handles inequality comparison operators that need special handling to commute</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">operands.</span></span><br><span class="line">[CommuteVarInequality, Normalize]</span><br><span class="line">(Le | Lt | Ge | Gt $left:^(Variable) $right:(Variable))</span><br><span class="line">=&gt;</span><br><span class="line">(CommuteInequality (OpName) $left $right)</span><br><span class="line"></span><br><span class="line">===》</span><br><span class="line"></span><br><span class="line">// [CommuteVarInequality]</span><br><span class="line">    &#123;</span><br><span class="line">        _variable, _ := left.(*memo.VariableExpr)</span><br><span class="line">        if _variable == nil &#123;</span><br><span class="line">            _variable2, _ := right.(*memo.VariableExpr)</span><br><span class="line">            if _variable2 != nil &#123;</span><br><span class="line">                if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVarInequality) &#123;</span><br><span class="line">                    _expr := _f.funcs.CommuteInequality(opt.LtOp, left, _variable2).(opt.ScalarExpr)</span><br><span class="line">                    if _f.appliedRule != nil &#123;</span><br><span class="line">                        _f.appliedRule(opt.CommuteVarInequality, nil, _expr)</span><br><span class="line">                    &#125;</span><br><span class="line">                    _f.constructorStackDepth--</span><br><span class="line">                    return _expr</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>definne  转换</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SubqueryPrivate contains information related to a subquery (Subquery, Any,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exists). It is shared between the operators so that the same rules can be used</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">across all the subquery operators.</span></span><br><span class="line">[Private]</span><br><span class="line">define SubqueryPrivate &#123;</span><br><span class="line">    OriginalExpr Subquery</span><br><span class="line">    Ordering Ordering</span><br><span class="line"></span><br><span class="line">    # RequestedCol is set if there could possibly be other columns in the input</span><br><span class="line">    # (say, if there was an ordering that must be respected) besides the one that</span><br><span class="line">    # will eventually be output. It is only used for ArrayFlatten expressions.</span><br><span class="line">    RequestedCol ColumnID</span><br><span class="line"></span><br><span class="line">    # Cmp is only used for AnyOp.</span><br><span class="line">    Cmp Operator</span><br><span class="line"></span><br><span class="line">    # WasLimited indicates a limit was applied &quot;under&quot; the subquery to</span><br><span class="line">    # restrict how many rows are fetched to determine the result.  See</span><br><span class="line">    # e.g. the rule IntroduceExistsLimit.</span><br><span class="line">    WasLimited bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====》</span><br><span class="line"></span><br><span class="line">// SubqueryPrivate contains information related to a subquery (Subquery, Any,</span><br><span class="line">// Exists). It is shared between the operators so that the same rules can be used</span><br><span class="line">// across all the subquery operators.</span><br><span class="line">type SubqueryPrivate struct &#123;</span><br><span class="line">    OriginalExpr *tree.Subquery</span><br><span class="line">    Ordering     opt.Ordering</span><br><span class="line"></span><br><span class="line">    // RequestedCol is set if there could possibly be other columns in the input</span><br><span class="line">    // (say, if there was an ordering that must be respected) besides the one that</span><br><span class="line">    // will eventually be output. It is only used for ArrayFlatten expressions.</span><br><span class="line">    RequestedCol opt.ColumnID</span><br><span class="line"></span><br><span class="line">    // Cmp is only used for AnyOp.</span><br><span class="line">    Cmp opt.Operator</span><br><span class="line"></span><br><span class="line">    // WasLimited indicates a limit was applied &quot;under&quot; the subquery to</span><br><span class="line">    // restrict how many rows are fetched to determine the result.  See</span><br><span class="line">    // e.g. the rule IntroduceExistsLimit.</span><br><span class="line">    WasLimited bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如何生成explorer.og.go</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入口：case &quot;explorer&quot;:</span><br><span class="line">    var gen explorerGen</span><br><span class="line">    err = g.generate(compiled, gen.generate)</span><br><span class="line"></span><br><span class="line">调用接口：</span><br><span class="line">func (g *optgen) generate(compiled *lang.CompiledExpr, genFunc genFunc) error &#123;</span><br><span class="line">    var buf bytes.Buffer</span><br><span class="line"></span><br><span class="line">    buf.WriteString(&quot;// Code generated by optgen; DO NOT EDIT.\n\n&quot;)</span><br><span class="line"></span><br><span class="line">    genFunc(compiled, &amp;buf)  ------生成文件接口</span><br><span class="line"></span><br><span class="line">    var b []byte</span><br><span class="line">    var err error</span><br><span class="line"></span><br><span class="line">    if g.useGoFmt &#123;                               ----------对生成的文件进行格式检查</span><br><span class="line">        b, err = format.Source(buf.Bytes())</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            // Write out incorrect source for easier debugging.</span><br><span class="line">            b = buf.Bytes()</span><br><span class="line">            out := g.cmdLine.Lookup(&quot;out&quot;).Value.String()</span><br><span class="line">            err = fmt.Errorf(&quot;code formatting failed with Go parse error\n%s:%s&quot;, out, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        b = buf.Bytes()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Ignore any write error if another error already occurred.</span><br><span class="line">        _ = g.writeOutputFile(b)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = g.writeOutputFile(b)           --------------------写文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *explorerGen) generate(compiled *lang.CompiledExpr, w io.Writer) &#123;</span><br><span class="line">    g.compiled = compiled</span><br><span class="line">    g.md = newMetadata(compiled, &quot;xform&quot;)       -----指定生成正确变量名称</span><br><span class="line">    g.w = &amp;matchWriter&#123;writer: w&#125;</span><br><span class="line">    g.ruleGen.init(compiled, g.md, g.w)</span><br><span class="line"></span><br><span class="line">    g.w.writeIndent(&quot;package xform\n\n&quot;)</span><br><span class="line"></span><br><span class="line">    g.w.nestIndent(&quot;import (\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;\&quot;github.com/cockroachdb/cockroach/pkg/sql/opt\&quot;\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;\&quot;github.com/cockroachdb/cockroach/pkg/sql/opt/memo\&quot;\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;\&quot;github.com/cockroachdb/cockroach/pkg/sql/sem/tree\&quot;\n&quot;)</span><br><span class="line">    g.w.unnest(&quot;)\n\n&quot;)</span><br><span class="line"></span><br><span class="line">    g.genDispatcher()             --------具体实现</span><br><span class="line">    g.genRuleFuncs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">优化规则：</span><br><span class="line">[GenerateIndexScans, Explore]</span><br><span class="line">(Scan $scanPrivate:* &amp; (IsCanonicalScan $scanPrivate))</span><br><span class="line">=&gt;</span><br><span class="line">(GenerateIndexScans $scanPrivate)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (g *explorerGen) genDispatcher() &#123;</span><br><span class="line">    g.w.nestIndent(&quot;func (_e *explorer) exploreGroupMember(\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;state *exploreState,\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;member memo.RelExpr,\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;ordinal int,\n&quot;)</span><br><span class="line">    g.w.unnest(&quot;) (_fullyExplored bool)&quot;)</span><br><span class="line">    g.w.nest(&quot; &#123;\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;switch t := member.(type) &#123;\n&quot;)</span><br><span class="line"></span><br><span class="line">    for _, define := range g.compiled.Defines &#123;</span><br><span class="line">        // Only include exploration rules.</span><br><span class="line">        rules := g.compiled.LookupMatchingRules(string(define.Name)).WithTag(&quot;Explore&quot;)   --根据tag过滤</span><br><span class="line">        if len(rules) &gt; 0 &#123;</span><br><span class="line">            opTyp := g.md.typeOf(define)</span><br><span class="line">            format := &quot;case *%s: return _e.explore%s(state, t, ordinal)\n&quot;</span><br><span class="line">            g.w.writeIndent(format, opTyp.name, define.Name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.w.writeIndent(&quot;&#125;\n\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;// No rules for other operator types.\n&quot;)</span><br><span class="line">    g.w.writeIndent(&quot;return true\n&quot;)</span><br><span class="line">    g.w.unnest(&quot;&#125;\n\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newMetadata 说明：</span><br><span class="line"></span><br><span class="line">// newMetadata creates a new instance of metadata from the compiled expression.</span><br><span class="line">// The pkg parameter is used to correctly qualify type names. For example, if</span><br><span class="line">// pkg is &quot;memo&quot;, then:</span><br><span class="line">//</span><br><span class="line">//   memo.RelExpr     =&gt; RelExpr</span><br><span class="line">//   opt.ScalarExpr   =&gt; ScalarExpr</span><br><span class="line">//   memo.ScanPrivate =&gt; ScanPrivate</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">结果显示：</span><br><span class="line">func (_e *explorer) exploreGroupMember(</span><br><span class="line">    state *exploreState,</span><br><span class="line">    member memo.RelExpr,</span><br><span class="line">    ordinal int,</span><br><span class="line">) (_fullyExplored bool) &#123;</span><br><span class="line">    switch t := member.(type) &#123;</span><br><span class="line">    case *memo.ScanExpr:</span><br><span class="line">        return _e.exploreScan(state, t, ordinal)</span><br><span class="line">    case *memo.SelectExpr:</span><br><span class="line">        return _e.exploreSelect(state, t, ordinal)</span><br><span class="line">    case *memo.ProjectExpr:</span><br><span class="line">        return _e.exploreProject(state, t, ordinal)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="norm"><a href="#norm" class="headerlink" title="norm"></a>norm</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 mosquito mosquito   508 Dec  1 01:50 agg.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  4288 May 12 19:29 bool.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 10751 May 12 23:12 comp.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   660 Dec  1 01:50 cycle.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 33892 Dec  1 01:50 decorrelate.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  7210 Apr 22 02:23 fold_constants.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 17771 Dec  1 01:50 groupby.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  9982 Dec  1 01:50 inline.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 23042 Mar 29 18:01 join.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 10231 Dec  1 01:50 limit.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   573 Dec  1 01:50 max1row.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1257 Dec  1 01:50 mutation.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2188 Dec  1 01:50 numeric.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2771 Apr 24 01:53 ordering.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  7442 Dec  1 01:50 project.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  1144 Dec  1 01:50 project_set.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 16117 Dec  1 01:50 prune_cols.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  8561 Dec  1 01:50 reject_nulls.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 13269 Apr 24 01:53 scalar.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 13663 May 10 17:57 select.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  6440 Dec  1 01:50 set.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  6107 Dec  1 01:50 window.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   508 Dec  1 01:50 with.opt</span><br></pre></td></tr></table></figure>

<h4 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 mosquito mosquito 11004 May 10 17:57 groupby.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito 22604 May 10 17:57 join.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3439 May 10 17:57 limit.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  2345 May 10 17:57 project.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  3439 Dec  1 01:50 scan.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito  9369 Apr 24 01:53 select.opt</span><br><span class="line">-rw-r--r-- 1 mosquito mosquito   860 Dec  1 01:50 set.opt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>优化器</tag>
        <tag>normalize</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle的连接和explain</title>
    <url>/2022/08/08/oracle%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8Cexplain/</url>
    <content><![CDATA[<h2 id="一、连接oracle"><a href="#一、连接oracle" class="headerlink" title="一、连接oracle"></a>一、连接oracle</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sunbindeMacBook-Pro:proj sunbin$ ssh root@10.16.30.84</span><br><span class="line">oracle@10.16.30.84&#x27;s password: 111111</span><br><span class="line">[oracle@tc84 ~]$ unset http_proxy https_proxy</span><br><span class="line">sqlplus /nolog</span><br><span class="line">conn c##xl/cxl</span><br></pre></td></tr></table></figure>

<h3 id="oracle运行一个csv文件，并将结果输出到一个文件"><a href="#oracle运行一个csv文件，并将结果输出到一个文件" class="headerlink" title="oracle运行一个csv文件，并将结果输出到一个文件"></a>oracle运行一个csv文件，并将结果输出到一个文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span>  sqlplus c##xl<span class="operator">/</span>cxl</span><br><span class="line">spool <span class="keyword">on</span></span><br><span class="line">spool <span class="operator">/</span>root<span class="operator">/</span>mosquito_test<span class="operator">/</span>mosquito_test.csv</span><br><span class="line">@<span class="operator">/</span>root<span class="operator">/</span>mosquito_test<span class="operator">/</span>mosquito_test.sql</span><br><span class="line">spool off</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="二、六种查看执行计划的方法"><a href="#二、六种查看执行计划的方法" class="headerlink" title="二、六种查看执行计划的方法"></a>二、六种查看执行计划的方法</h2><p>（1）explain plan for<br>（2）set autotrace on<br>（3）statistics_level&#x3D;all<br>（4）dbms_xplan.display_cursor获取<br>（5）事件10046 trace跟踪<br>（6）awrsqrpt.sql</p>
<h3 id="Oracle提供了6种执行计划获取方法，各种方法侧重点不同。"><a href="#Oracle提供了6种执行计划获取方法，各种方法侧重点不同。" class="headerlink" title="Oracle提供了6种执行计划获取方法，各种方法侧重点不同。"></a>Oracle提供了6种执行计划获取方法，各种方法侧重点不同。</h3><h3 id="第一种-：explain-for"><a href="#第一种-：explain-for" class="headerlink" title="第一种 ：explain for"></a>第一种 ：explain for</h3><pre><code>步骤一：explain paln for  查询sql语句
步骤二：select * from table(dbms_xplan.display());
</code></pre>
<p>&#x2F;*<br>优点：无需真正执行，快捷方便；<br>缺点：1.没有输出相关统计信息，例如产生了多少逻辑读，多少次物理读，多少次递归调用的情况；<br>2.无法判断处理了多少行；<br>3.无法判断表执行了多少次<br>*&#x2F;</p>
<h3 id="第二种：set-autotrace-on"><a href="#第二种：set-autotrace-on" class="headerlink" title="第二种：set autotrace on"></a>第二种：set autotrace on</h3><pre><code>  步骤一：sql&gt; set autotrace on traceonly;

  步骤二：sql&gt; 执行查询Sql语句

  步骤三：sql&gt; set autotrace off;
</code></pre>
<p>&#x2F;*<br>优点：1.可以输出运行时的相关统计信息（产生多少逻辑读、多少次递归调用、多少次物理读等）；<br>2.虽然要等语句执行完才能输出执行计划，但是可以有traceonly开关来控制返回结果不打屏输出；<br>缺点：1.必须要等SQL语句执行完，才出结果；<br>2.无法看到表被访问了多少次；<br>*&#x2F;</p>
<h3 id="第三种：（3）statistics-level-x3D-all"><a href="#第三种：（3）statistics-level-x3D-all" class="headerlink" title="第三种：（3）statistics_level&#x3D;all"></a>第三种：（3）statistics_level&#x3D;all</h3><p>步骤一：ALTER SESSION SET STATISTICS_LEVEL&#x3D;ALL;<br>步骤二：执行待分析的SQL<br>步骤三：select * from table(dbms_xplan.display_cursor(null,null,’allstats last’));<br>&#x2F;*<br>关键字解读：<br>1.starts：SQL执行的次数；<br>2.E-Rows：执行计划预计返回的行数；<br>3.R-Rows：执行计划实际返回的行数；<br>4.A-Time：每一步执行的时间(HH:MM:SS.FF)，根据这一行可知SQL耗时在哪些地方；<br>5.Buffers：每一步实际执行的逻辑读或一致性读；<br>6.Reads：物理读；<br>7.OMem：OMem为最优执行模式所需的内存评估值， 这个数据是由优化器统计数据以及前一次执行的性能数据估算得出的；<br>8.1Mem：1Mem为one-pass模式所需的内存评估值，当工作区大小无法满足操作所需的大小时，需要将部分数据写入临时磁盘空间中(如果仅需要写入一次就可以完成操作，就称一次通过，One-Pass;否则为多次通过，Multi-Pass).该列数据为语句最后一次执行中，单次写磁盘所需要的内存大小，这个由优化器统计数据以及前一次执行的性能数据估算得出的<br>9.Used_Mem：Used-Mem则为当前操作实际执行时消耗的内存，括号里面为(发生磁盘交换的次数,1次即为One-Pass,大于1次则为Multi_Pass,如果没有使用磁盘，则显示0)<br>*&#x2F;</p>
<p>&#x2F;*<br>优点：1.可以清晰的从starts得出表被访问多少次；<br>2.可以从E-Rows和A-Rows得到预测的行数和真实的行数，从而可以准确判断Oracle评估是否准确；<br>3.虽然没有准确的输出运行时的相关统计信息，但是执行计划中的Buffers就是真实的逻辑读的数值；<br>缺点：1.必须要等执行完后才能输出结果；<br>2.无法控制结果打屏输出，不像autotrace可以设置traceonly保证不输出结果；<br>3.看不出递归调用，看不出物理读的数值<br>*&#x2F;</p>
<h3 id="第四种：dbms-xplan-display-cursor获取"><a href="#第四种：dbms-xplan-display-cursor获取" class="headerlink" title="第四种：dbms_xplan.display_cursor获取"></a>第四种：dbms_xplan.display_cursor获取</h3><pre><code>步骤1：select * from table( dbms_xplan.display_cursor(&#39;&amp;sql_id&#39;) );    --该方法是从共享池得到，如果SQL已被age out出share pool，则查找不到
</code></pre>
<p>注释：<br>1.还有1种方法，select * from table( dbms_xplan.display_awr(‘&amp;sql_id’) );  –该方法是从awr性能视图里面获取<br>2.如果有多个执行计划，可用以下方法查出：<br>select * from table(dbms_xplan.display_cursor(‘&amp;sql_id’,0));<br>select * from table(dbms_xplan.display_cursor(‘&amp;s ql_id’,1));</p>
<p>&#x2F;*<br>优点：1.知道sql_id即可得到执行计划，与explain plan for一样无需执行；<br>2.可得到真实的执行计划</p>
<p>缺点：1.没有输出运行的统计相关信息；<br>2.无法判断处理了多少行；<br>3.无法判断表被访问了多少次；<br>*&#x2F;</p>
<h3 id="第五种：事件10046-trace跟踪"><a href="#第五种：事件10046-trace跟踪" class="headerlink" title="第五种：事件10046 trace跟踪"></a>第五种：事件10046 trace跟踪</h3><p>&#x2F;*<br>步骤1：alter session set events ‘10046 trace name context forever,level 12’;            –开启追踪<br>步骤2：执行sql语句；<br>步骤3：alter session set events ‘10046 trace name context off’;                                 –关闭追踪<br>步骤4：select tracefile from v$process where addr&#x3D;(select paddr from v$session where sid&#x3D;(select sid from v$mystat where rownum&lt;&#x3D;1));       –找到跟踪后产生的文件<br>步骤5：tkprof  trc文件    生成目标文件  sys&#x3D;no sort&#x3D;prsela,exeela,fchela                           –格式化命令<br>*&#x2F;</p>
<h3 id="第六种：awrsqrpt-sql"><a href="#第六种：awrsqrpt-sql" class="headerlink" title="第六种：awrsqrpt.sql"></a>第六种：awrsqrpt.sql</h3><p>&#x2F;*<br>步骤1：@?&#x2F;rdbms&#x2F;admin&#x2F;awrsqrpt.sql<br>步骤2：选择你要的断点（begin snap和end snap）<br>步骤3：输入要查看的sql_id<br>*&#x2F;</p>
<p>例子：<br>见：使用awrsqrpt.sql查看执行计划demo</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>选择时一般遵循以下规则：<br>1.如果sql执行很长时间才出结果或返回不了结果，用方法1：explain plan for<br>2.跟踪某条sql最简单的方法是方法1：explain plan for，其次是方法2：set autotrace on<br>3.如果相关查询某个sql多个执行计划的情况，只能用方法4：dbms_xplan.display_cursor或方法6：awrsqrpt.sql<br>4.如果sql中含有函数，函数中有含有sql，即存在多层调用，想准确分析只能用方法5：10046追踪<br>5.想法看到真实的执行计划，不能用方法1：explain plan for和方法2：set autotrace on<br>6.想要获取表被访问的次数，只能用方法3：statistics_level &#x3D; all</p>
]]></content>
      <categories>
        <category>oracle</category>
        <category>test</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>sqllogictest</title>
    <url>/2022/03/10/sqllogictest/</url>
    <content><![CDATA[<h3 id="在cockroachDB中设计的位置为pkg-x2F-sql-x2F-logictest-x2F-logic-go"><a href="#在cockroachDB中设计的位置为pkg-x2F-sql-x2F-logictest-x2F-logic-go" class="headerlink" title="在cockroachDB中设计的位置为pkg&#x2F;sql&#x2F;logictest&#x2F;logic.go"></a>在cockroachDB中设计的位置为pkg&#x2F;sql&#x2F;logictest&#x2F;logic.go</h3><p>更多用法也可以参照sqllogictest <a href="https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki">官方文档</a><br>    1、注释：#<br>    2、不要求返回结果的语句（如建表，增删改）：<br>    3、每个语句后接一个SQL命令，预期成功ok，预期失败error<br>        statement ok	#注意末尾不要加  ‘;’<br>        statement error	</p>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><h4 id="1、预期返回结果并进行比较"><a href="#1、预期返回结果并进行比较" class="headerlink" title="1、预期返回结果并进行比较"></a>1、预期返回结果并进行比较</h4><pre><code>query &lt;type-string&gt; &lt;sort-mode&gt; &lt;label&gt;
----	#如果不加则返回空集
&lt;expected result&gt;
1
2
3
</code></pre>
<h4 id="2、其中-lt-type-string-gt-返回数据类型，包含有TIR"><a href="#2、其中-lt-type-string-gt-返回数据类型，包含有TIR" class="headerlink" title="2、其中 &lt; type-string&gt;返回数据类型，包含有TIR"></a>2、其中 &lt; type-string&gt;返回数据类型，包含有TIR</h4><pre><code>T-文本
I-整型
R-浮点
B-布尔
O-行标识符
</code></pre>
<h4 id="3、-lt-sort-mode-gt-包含nosort，rowsort，valuesort"><a href="#3、-lt-sort-mode-gt-包含nosort，rowsort，valuesort" class="headerlink" title="3、&lt; sort-mode&gt;包含nosort，rowsort，valuesort"></a>3、&lt; sort-mode&gt;包含nosort，rowsort，valuesort</h4><pre><code>nosort-按数据库输出结果显示（默认）
rowsort-输出后再进行排序，按照ASCII码排序
valuesort-和rowsort一样，但是不是按行分组
</code></pre>
<h4 id="4、-lt-label-gt"><a href="#4、-lt-label-gt" class="headerlink" title="4、&lt; label&gt;"></a>4、&lt; label&gt;</h4><pre><code>如果添加的话，会保存查询结果备重用
对于返回结果：
整型-%d
浮点-%.3f
空值-NUL
空字符串-empty
控制字符或不可打印的-@
控制记录
测试过程中需要控制情况下用下列语句：
halt
hash-threshold &lt;max-result-set-size&gt;
1
2
halt停止供调试使用，可以使数据库处于出bug状态
</code></pre>
<p>hash-threshold &lt; max-result-set-size&gt;对结果集中的值数量限制，如果超出了数量，则存储所有值得哈希值，而不是存储在脚本中</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="1、statement和query可以使用下列前缀，去跳过某些数据库执行下列语句："><a href="#1、statement和query可以使用下列前缀，去跳过某些数据库执行下列语句：" class="headerlink" title="1、statement和query可以使用下列前缀，去跳过某些数据库执行下列语句："></a>1、statement和query可以使用下列前缀，去跳过某些数据库执行下列语句：</h4><pre><code>skipif &lt;database-name&gt;
onlyif &lt;database-name&gt;
</code></pre>
]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>安装postgres</title>
    <url>/2022/02/08/%E5%AE%89%E8%A3%85postgres/</url>
    <content><![CDATA[<h2 id="1、-下載源碼包，并解壓"><a href="#1、-下載源碼包，并解壓" class="headerlink" title="1、 下載源碼包，并解壓"></a>1、 下載源碼包，并解壓</h2><ul>
<li>wget <a href="https://ftp.postgresql.org/pub/source/v14.2/postgresql-14.2.tar.bz2">https://ftp.postgresql.org/pub/source/v14.2/postgresql-14.2.tar.bz2</a></li>
<li>tar -jxvf postgresql-14.2.tar.bz2</li>
</ul>
<h2 id="2、进入解压包編譯安裝"><a href="#2、进入解压包編譯安裝" class="headerlink" title="2、进入解压包編譯安裝"></a>2、进入解压包編譯安裝</h2><ul>
<li><p>.&#x2F;configure –prefix&#x3D;&#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres –enable-debug –enable-cassert –enable-depend CFLAGS&#x3D;-O0</p>
</li>
<li><p>–prefix : 指定安装的目录</p>
</li>
<li><p>–enable-debug : 把所有程序和库以带有调试符号的方式编译</p>
</li>
<li><p>–enable-cassert : 打开服务器中的断言（assertion）检查，它会检查许多”不可能发生”的条件。</p>
</li>
<li><p>–enable-depend ： 打开自动依赖性跟踪。</p>
</li>
<li><p>CFLAGS&#x3D;-O0 ： 关闭优化</p>
</li>
<li><p>make &amp;&amp; make install</p>
</li>
</ul>
<h2 id="3、进入安装目录，第一次需要初始化数据库（使用initdb）"><a href="#3、进入安装目录，第一次需要初始化数据库（使用initdb）" class="headerlink" title="3、进入安装目录，第一次需要初始化数据库（使用initdb）"></a>3、进入安装目录，第一次需要初始化数据库（使用initdb）</h2><ul>
<li>cd &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres&#x2F;bin</li>
<li>.&#x2F;initdb -D &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres_data</li>
</ul>
<h2 id="4、启动并且连接"><a href="#4、启动并且连接" class="headerlink" title="4、启动并且连接"></a>4、启动并且连接</h2><ul>
<li>.&#x2F;pg_ctl -D &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres_data -l logfile start</li>
<li>.&#x2F;psql -d postgres</li>
</ul>
<h2 id="5、服务器的启动、停止、再启动："><a href="#5、服务器的启动、停止、再启动：" class="headerlink" title="5、服务器的启动、停止、再启动："></a>5、服务器的启动、停止、再启动：</h2><ul>
<li>启动：pg_ctl start -l logfile -D &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres_data</li>
<li>停止：pg_ctl stop -D &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres_data</li>
<li>重新启动：pg_ctl restart -l logfile -D &#x2F;home&#x2F;crdb&#x2F;postgresql&#x2F;postgres_data</li>
</ul>
<h2 id="6、使用数据库"><a href="#6、使用数据库" class="headerlink" title="6、使用数据库"></a>6、使用数据库</h2><ul>
<li><p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">department <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;xql&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;test&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;math&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;temp&#x27;</span>,<span class="number">3</span>, <span class="string">&#x27;ai&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Student;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[crdb<span class="variable">@localhost</span> bin]$ .<span class="operator">/</span>pg_ctl <span class="operator">-</span>D <span class="operator">/</span>home<span class="operator">/</span>crdb<span class="operator">/</span>postgresql<span class="operator">/</span>postgres_data <span class="operator">-</span>l logfile <span class="keyword">start</span></span><br><span class="line">waiting <span class="keyword">for</span> server <span class="keyword">to</span> start.... done</span><br><span class="line">server started</span><br><span class="line">[crdb<span class="variable">@localhost</span> bin]$ .<span class="operator">/</span>psql <span class="operator">-</span>d postgres</span><br><span class="line">psql (<span class="number">14.2</span>)</span><br><span class="line">Type &quot;help&quot; <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">postgres(# name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">postgres(# id <span class="type">int</span>,</span><br><span class="line">postgres(# department <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">postgres(# );</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span></span><br><span class="line">postgres<span class="operator">-</span># (<span class="string">&#x27;xql&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">postgres<span class="operator">-</span># (<span class="string">&#x27;test&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;math&#x27;</span>),</span><br><span class="line">postgres<span class="operator">-</span># (<span class="string">&#x27;temp&#x27;</span>,<span class="number">3</span>, <span class="string">&#x27;ai&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Student;</span><br><span class="line"> name <span class="operator">|</span> id <span class="operator">|</span> department</span><br><span class="line"><span class="comment">------+----+------------</span></span><br><span class="line"> xql  <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> info</span><br><span class="line"> test <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> math</span><br><span class="line"> temp <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> ai</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span>#</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7、调试"><a href="#7、调试" class="headerlink" title="7、调试"></a>7、调试</h2><ul>
<li>获取进程id号<br>select pg_backend_pid();</li>
<li>gdb attach pid</li>
<li>gdb) n</li>
<li>gdb) c</li>
<li>使用图形界面看  断点代码 ctrl + x + a （严格先后顺序）</li>
</ul>
<h2 id="8、gdb-常用命令"><a href="#8、gdb-常用命令" class="headerlink" title="8、gdb 常用命令"></a>8、gdb 常用命令</h2><ul>
<li>命令        简写形式    说明</li>
<li>list        l    查看源码</li>
<li>backtrace    bt、where    打印函数栈信息</li>
<li>next        n    执行下一行</li>
<li>step        s    一次执行一行，遇到函数会进入</li>
<li>finish         运行到函数结束</li>
<li>continue    c    继续运行</li>
<li>break        b    设置断点</li>
<li>info breakpoints         显示断点信息</li>
<li>delete       d    删除全部断点</li>
<li>print        p    打印表达式的值</li>
<li>run            r    启动程序</li>
<li>until        u    执行到指定行</li>
<li>info        i    显示信息</li>
<li>help        h    帮助信息</li>
</ul>
<h2 id="9、找内置函数date-part时的断点设置"><a href="#9、找内置函数date-part时的断点设置" class="headerlink" title="9、找内置函数date_part时的断点设置"></a>9、找内置函数date_part时的断点设置</h2><p><a href="https://blog.csdn.net/qq_28351609/article/details/114855630">GDB调试命令详解</a></p>
]]></content>
      <categories>
        <category>pg</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>opt官方文档解读</title>
    <url>/2023/01/01/opt%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="地址指路"><a href="#地址指路" class="headerlink" title="地址指路"></a>地址指路</h2><p><a href="https://www.cockroachlabs.com/blog/building-cost-based-sql-optimizer/">https://www.cockroachlabs.com/blog/building-cost-based-sql-optimizer/</a></p>
<h2 id="主要文章内容"><a href="#主要文章内容" class="headerlink" title="主要文章内容"></a>主要文章内容</h2><h3 id="What-is-a-SQL-optimizer-anyway"><a href="#What-is-a-SQL-optimizer-anyway" class="headerlink" title="What is a SQL optimizer anyway?"></a>What is a SQL optimizer anyway?</h3><p>A SQL optimizer analyzes a SQL query and chooses the most efficient way to execute it.<br>While the simplest queries might have only one way to execute, more complex queries can<br>have thousands, or even millions, of ways. The better the optimizer, the closer it gets<br>to choosing the optimal execution plan, which is the most efficient way to execute a query.<br>一个SQL优化器分析一个SQL查询，并选择最有效的方式来执行它。虽然最简单的查询可能只有一种执行方式，<br>但更复杂的查询可能有数千甚至数百万种方式。优化器越好，它就越接近于选择最佳执行计划，也就是执行查询的最有效方式。</p>
<blockquote>
<p>Here’s a query that looks deceptively simple:</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers c, orders o</span><br><span class="line"><span class="keyword">WHERE</span> c.id<span class="operator">=</span>o.cust_id <span class="keyword">AND</span> c.name <span class="operator">&lt;</span> ’John Doe’</span><br></pre></td></tr></table></figure>

<p>I won’t bore you (or me) with the exhaustive list of questions that the optimizer<br>must answer about this query, but here are a few to make my point:</p>
<ul>
<li>1、Should we evaluate the name filter before the join or after the join?</li>
<li>2、Should we use a hash join, merge join, or a nested loop join with an index (called<br>   a “lookup join” in CockroachDB)?</li>
<li>3、If a lookup or hash join, should we enumerate customers and then lookup orders?<br>   Or enumerate orders and then lookup customers?</li>
<li>4、If there’s a secondary index on “name”, should we use that to find matching names,<br>   or is it better to use the primary index to find matching ids?<br>我不会让你（或我）厌烦优化器必须回答的所有问题的清单，但这里有几个问题可以说明我的观点。</li>
<li>1、我们应该在连接前还是连接后评估名称过滤器？</li>
<li>2、我们应该使用散列连接、合并连接，还是使用带有索引的嵌套循环连接（在Cock中称为<br>在CockroachDB中称为 “查找连接”）？</li>
<li>3、如果是查找或哈希连接，我们应该先列举客户，再查找订单？ 还是先列举订单然后再查找客户？</li>
<li>4、如果在 “name “上有一个二级索引，我们应该用它来寻找匹配的名字。<br>还是使用主索引来寻找匹配的ID？</li>
</ul>
<p>Furthermore, it’s not enough for the optimizer to answer each of these questions in isolation.<br>To find the best plan, it needs to look at combinations of answers. Maybe it’s best to use the<br>secondary index when choosing the lookup join. But, if a merge join is used instead, the<br>primary index may be better. The optimal execution plan depends on row counts, relative<br>performance of the various physical operators, the location and frequency of data values,<br>and … a lot of other stuff.<br>此外，对于优化器来说，单独地回答这些问题是不够的。<br>为了找到最好的计划，它需要看一下答案的组合。<br>也许在选择查找连接（lookup join）时，最好是使用二级索引。<br>但是，如果使用的是合并连接（merge join），那么主索引可能更好。<br>最佳的执行计划取决于行数、各种物理运算符的相对性能，数据值的位置和频率。 以及……很多其他的东西。</p>
<h3 id="Heuristic-vs-cost-based"><a href="#Heuristic-vs-cost-based" class="headerlink" title="Heuristic vs. cost-based"></a>Heuristic vs. cost-based</h3><p>So how do optimizers choose among so many possible execution plans?<br>People have been thinking and writing about that longer than I’ve been alive,<br>so any answer’s going to be inadequate. But, it’s still valuable to discuss<br>two common approaches to the problem.<br>那么，优化器是如何在这么多可能的执行计划中进行选择的呢？<br>人们思考和写这个问题的时间比我还长，所以任何答案都是不充分的。<br>但是，讨论一下以下问题还是很有价值的 两个解决这个问题的常见方法。</p>
<p>The first approach is what everyone who builds an optimizer for the first time takes.<br>They come up with preset heuristic rules based on general principles. For example, there<br>might be a heuristic rule to always use a hash join instead of a nested loop join<br>if an equality condition is present. In most situations, that will result in a better<br>execution plan, and so it’s a good heuristic. An optimizer based on rules like this is<br>called a heuristic optimizer.<br>第一种方法是每个第一次建立优化器的人都会采取的方法。 他们根据一般的原则提出了预设的启发式规则。<br>例如，有可能有一个启发式规则，即如果有一个相等的条件，总是使用散列连接而不是嵌套循环连接。<br>在大多数情况下，这将导致一个更好的执行计划，所以这是一个很好的启发式方法。<br>一个基于这样的规则的优化器被称为被称为启发式优化器。</p>
<p>However, static heuristic rules have a downside. They work well in most cases, but they<br>can fail to find the best plan in other cases. For example, a lookup join loops over rows<br>from an outer relation and looks for inner rows that match by repeatedly probing into<br>an index over the inner relation. This works well when the number of outer rows is small,<br>but degrades as that number rises and the overhead of probing for every row begins to<br>dominate execution time. At some cross-over point, a hash or merge join would have<br>been better. But it’s difficult to devise heuristics that capture these subtleties.<br>然而，静态启发式规则有一个弊端。它们在大多数情况下工作良好，但在其他情况下，它们可能无法找到最佳方案。<br>例如，一个查找连接（lookup join）在外部关系的行上循环，并通过重复探测内部关系的索引来寻找匹配的内部行。<br>当外部行的数量较少时，这种方法效果很好，但是随着外部行数量的增加，探测每条行的开销开始主导执行时间，这种方法就会变差。<br>在某个交叉点上，哈希（hash join）或合并连接（merge join）会更好。但很难设计出能抓住这些微妙之处的启发式方法。</p>
<p>Enter the cost-based optimizer. A cost-based optimizer will enumerate possible execution<br>plans and assign a cost to each plan, which is an estimate of the time and resources<br>required to execute that plan. Once the possibilities have been enumerated, the optimizer<br>picks the lowest cost plan and hands it off for execution. While a cost model is typically<br>designed to maximize throughput (i.e. queries per second), it can be designed to favor<br>other desirable query behavior, such as minimizing latency (i.e. time to retrieve first row)<br>or minimizing memory usage.<br>进入基于成本的优化器。基于成本的优化器将列举可能的执行计划，并给每个计划分配一个成本，这是对执行该计划所需时间和资源的估计。<br>一旦列举出各种可能性，优化器就会挑选出成本最低的计划，并将其移交给执行。虽然成本模型的设计通常是为了最大限度地提高吞吐<br>量（即每秒的查询次数），但它也可以被设计成有利于其他理想的查询行为，如最小化延迟（即检索第一行的时间）或最小化内存使用量<br>或最小化内存使用。</p>
<p>At this point, you may be thinking, “but what if that cost model turns out to be wrong?”.<br>That’s a good question, and it’s true that a cost-based optimizer is only as good as the<br>costs it assigns. Furthermore, it turns out that the accuracy of the costs are highly<br>dependent on the accuracy of the row count estimates made by the optimizer. These are<br>exactly what they sound like: the optimizer estimates how many rows will be returned by<br>each stage of the query plan. This brings us to another subject of decades of research:<br>database statistics.<br>在这一点上，你可能会想，”但如果那个成本模型被证明是错误的呢？”。<br>这是一个很好的问题，而且基于成本的优化器确实只和它所分配的成本一样好。<br>此外，事实证明，成本的准确性在很大程度上取决于优化器对行数估计的准确性。<br>这些正是它们听起来的样子：优化器估计查询计划的每个阶段会有多少行被返回。<br>这就把我们带到了几十年来的另一个研究主题：数据库统计。</p>
<p>The goal of gathering database statistics is to provide information to the optimizer so<br>that it can make more accurate row count estimates. Useful statistics include row counts<br>for tables, distinct and null value counts for columns, and histograms for understanding<br>the distribution of values. This information feeds into the cost model and helps decide<br>questions of join type, join ordering, index selection, and more.<br>收集数据库统计数据的目的是为优化器提供信息，以便它能做出更准确的行数估计。<br>有用的统计数据包括表的行数、列的独立值和空值计数，以及用于了解数值分布的直方图。<br>这些信息会反馈到成本模型中，并帮助决定连接类型、连接排序、索引选择等问题。</p>
<h3 id="Re-birth-of-an-optimizer"><a href="#Re-birth-of-an-optimizer" class="headerlink" title="(Re)birth of an optimizer"></a>(Re)birth of an optimizer</h3><p>CockroachDB started with a simple heuristic optimizer that grew more complicated over time,<br>as optimizers tend to do. By our 2.0 release, we had started running into limitations of the<br>heuristic design that we could not easily circumvent. Carefully-tuned heuristic rules were<br>beginning to conflict with one another, with no clear way to decide between them. A simple<br>heuristic like:<br>CockroachDB从一个简单的启发式优化器开始，随着时间的推移，这个优化器变得越来越复杂。<br>到了2.0版本，我们开始遇到了启发式设计的局限性，我们无法轻易规避。<br>精心调整的启发式规则开始相互冲突，没有明确的方法来决定它们之间的关系。<br>一个简单的 启发式规则，例如：</p>
<blockquote>
<p>“use hash join when an equality condition is present”</p>
</blockquote>
<p>became:</p>
<blockquote>
<p>“use hash join when an equality condition is present, unless both inputs are sorted on<br>the join key, in which case use a merge join”</p>
</blockquote>
<p>near the end, we contemplated heuristics like:</p>
<blockquote>
<p>“use hash join when an equality condition is present, unless both inputs are sorted on the join<br>key, in which case use a merge join; that is, except if one join input has a small number of<br>rows and there’s an index available for the other input, in which case use a lookup join”</p>
</blockquote>
<p>Every new heuristic rule we added had to be examined with respect to every heuristic rule<br>already in place, to make sure that they played nicely with one another. And while even<br>cost-based optimizers sometimes behave like a delicately balanced Jenga tower, heuristic<br>optimizers fall over at much lower heights.<br>我们增加的每一条新的启发式规则都必须与已经存在的每一条启发式规则一起进行审查，以确保它们彼此之间的关系良好（没有冲突和循环）。<br>而且即使是甚至基于成本的优化器有时也会表现得像一个微妙平衡的Jenga tower（积木塔），而启发式优化器在更低的高度上就会倒下。</p>
<p>By the last half of 2017, momentum was growing within Cockroach Labs to replace the heuristic<br>optimizer that was showing its age. Peter Mattis, one of our co-founders, arranged to have an<br>outside expert on database optimizers run a months-long bootcamp, with the goal of teaching our<br>developers how state-of-the-art optimizers work, complete with homework assignments to read<br>seminal papers on the subject. In order to kickstart discussion and momentum, Peter created a<br>cost-based optimizer prototype called “opttoy”, that demonstrated some of the important concepts,<br>and informed the production work that followed.<br>到2017年下半年，Cockroach实验室内取代正在显示其年龄的启发式优化器的势头正在增长。<br>们的联合创始人之一彼得-马蒂斯（Peter Mattis）安排了一位数据库优化器方面的外部专家举办了为期数月的训练营，<br>目的是教我们的开发人员如何使用最先进的优化器，并布置家庭作业来阅读 在这个问题上的开创性论文。<br>为了启动讨论和动力，彼得创建了一个 为了启动讨论和势头，Peter创造了一个基于成本的优化器原型，名为 “opttoy”，它展示了一些重要的概念。<br>并为随后的生产工作提供参考。</p>
<p>By the time I joined the company in early 2018, the company had come to the collective<br>decision that it was now time to take the next step forward. Given my background and interest<br>in the subject, I was tasked with leading a small (but highly motivated) team to build a<br>cost-based optimizer from scratch. After 9 months of intense effort, our team is releasing<br>the first version of the new optimizer as part of the CockroachDB 2.1 release. While there’s<br>still much more we can (and will) do, this first release represents an important step forward.<br>Here are a couple of important new capabilities that the 2.1 cost-based optimizer supports:<br>当我在2018年初加入公司的时候，公司已经做出了集体决定，现在是采取下一步行动的时候了。<br>鉴于我的背景和兴趣 鉴于我的背景和兴趣，我的任务是领导一个小型（但积极性很高）的团队，从头开始建立一个基于成本的优化器。<br>经过9个月的紧张努力，我们的团队发布了新优化器的第一个版本，作为CockroachDB 2.1版本的一部分。<br>虽然我们还有很多可以做的事情，但这第一个版本代表了我们向前迈出的重要一步。<br>以下是2.1版本基于成本的优化器所支持的几个重要的新功能：</p>
<ul>
<li><p>Correlated subqueries - these are queries that contain an inner subquery that references</p>
</li>
<li><p>a column from an outer query, such as in this example:</p>
</li>
<li><p>相关子查询 – 这些查询包含一个内部子查询，该子查询引用了外部查询的一个列，如本例中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.cust_id <span class="operator">=</span> c.id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Optimizing correlated subqueries is another blog post all on its own, which I hope to<br>cover in the future.<br>优化相关的子查询是另一篇独立的博客文章，我希望在未来能够涉及到。</p>
</li>
<li><p>Automatic planning of lookup joins: When deciding how to execute a join, the optimizer<br>now considers lookup joins, in addition to merge and hash joins. Lookup joins are<br>important for fast execution of equality joins, where one input has a small number of<br>rows and the other has an index on the equality condition:</p>
</li>
<li><p>查找连接（lookup join）的自动规划：当决定如何执行一个连接时，优化器除了合并（merge join）和哈希连接（hash join）之外， 现在还考虑查找连接（lookup join）。</p>
</li>
<li><p>查找连接（lookup join）对于快速执行等价连接（equality joins）很重要，其中一个输入有少量的行，而另一个则有一个关于等价条件（equality condition）的索引。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> customers c, orders o</span><br><span class="line"><span class="keyword">WHERE</span> c.id<span class="operator">=</span>o.cust_id <span class="keyword">AND</span> c.zip<span class="operator">=</span><span class="string">&#x27;12345&#x27;</span> <span class="keyword">AND</span> c.name<span class="operator">=</span><span class="string">&#x27;John Doe&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Here, the optimizer would consider a plan that first finds customers named “John Doe”<br>who live in zip code “12345” (likely to be a small number of rows), and then probes into<br>the orders table to count rows.<br>在这里，优化器会考虑一个计划，首先找到居住在邮政编码 “12345 “的名为 “John Doe “的客户（可能是少量的行），然后探测订单表以计数行。</p>
<h3 id="Under-the-Hood"><a href="#Under-the-Hood" class="headerlink" title="Under the Hood"></a>Under the Hood</h3><p>As promised, I want to give you a quick peek under the hood of the new optimizer. To start,<br>it’s useful to think of a query plan as a tree, with each node in the tree representing a<br>step in the execution plan. In fact, that’s how the SQL EXPLAIN statement shows an execution plan:<br>正如承诺的那样，我想给你一个快速窥视新优化器的引擎。<br>首先，把查询计划看作一棵树是很有用的，树上的每个节点都代表执行计划中的一个步骤。<br>事实上，这就是SQL EXPLAIN语句显示执行计划的方式。</p>
<p><img src="/img/images_optimizer/a_simple_execution.png"></p>
<p>This output shows how the unoptimized plan would execute: first compute a full cross-product<br>of the customers and orders tables, then filter the resulting rows based on the WHERE conditions,<br>and finally compute the count_rows aggregate. But that would be a terrible plan! If there were<br>10,000 customers and 100,000 orders, then the cross-product would generate 1 billion rows,<br>almost all of which would simply be filtered away. What a waste.<br>这个输出显示了未经优化的计划是如何执行的：首先计算customers和orders表的完整交叉产品，然后根据WHERE条件过滤得到的行，<br>最后计算count_rows聚合。但是这将是一个糟糕的计划! 如果有10,000个客户和100,000个订单，那么交叉产品将产生10亿行，<br>几乎所有的行都会被过滤掉。这真是一种浪费。</p>
<p>Here’s where the optimizer proves its worth. Its job is to transform that starting plan tree<br>into a series of logically equivalent plan trees, and then pick the tree that has the lowest cost.<br>So what does “logically equivalent” mean? Two plan trees are logically equivalent if they both<br>return the same data when executed (though rows can be ordered differently if there is no ORDER<br>BY clause). In other words, from a correctness point of view, it doesn’t matter which plan the<br>optimizer picks; its choice is purely about maximizing performance.<br>这里是优化器证明其价值的地方。它的工作是将起始计划树转化为一系列逻辑上等价的计划树，然后挑选成本最低的计划树。<br>那么，”逻辑上等价 “是什么意思？如果两个计划树在执行时返回相同的数据，那么它们在逻辑上就是等价的（尽管如果没有ORDER BY子句，<br>行的排序可以不同）。换句话说，从正确性的角度来看，优化器选择哪个计划并不重要；它的选择纯粹是为了使性能最大化。</p>
<h3 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h3><p>The optimizer does not generate the complete set of equivalent plan trees in one step.<br>Instead, it starts with the initial tree and performs a series of incremental transformations to<br>generate alternative trees. Each individual transformation tends to be relatively simple on its own;<br>it is the combination of many such transformations that can solve complex optimization challenges.<br>Watching an optimizer in action can be magical; even if you understand each individual<br>transformation it uses, often it will find surprising combinations that yield unexpected plans.<br>Even for the relatively simple query shown above, the optimizer applies 12 transformations to<br>reach the final plan. Below is a diagram showing 4 of the key transformations.<br>优化器并不在一个步骤中生成完整的等价计划树集。相反，它从最初的树开始，执行一系列的增量转换来生成替代树。<br>每个单独的转换本身往往是相对简单的；正是许多这样的转换的组合，可以解决复杂的优化挑战。<br>观察一个优化器的运作是很神奇的；即使你了解它使用的每一个单独的变换，它也会找到令人惊讶的组合，产生意想不到的计划。<br>即使是上面显示的相对简单的查询，优化器也应用了12种转换来达到最终的计划。下面的图表显示了其中的4个关键转换。</p>
<p><img src="/img/images_optimizer/equal_plans.png"></p>
<p>You can see that the filter conditions get “pushed down” into the join and then become part of<br>the scan operator for maximum performance. During the final transformation, the optimizer decides<br>to use a lookup join with a secondary index to satisfy the query.<br>你可以看到，过滤条件被 “向下推 “到连接中，然后成为扫描操作的一部分，以获得最大的性能。<br>在最后的转换过程中，优化器决定使用一个带有二级索引的查找连接（lookup join）来满足查询。</p>
<p>As of this writing, the cost-based optimizer implements over 160 different transformations, and we<br>expect to add many more in future releases. And because transformations lie at the heart of the new<br>optimizer, we spent a lot of time making them as easy as possible to define, understand, and maintain.<br>To that end, we created a domain specific language (DSL) called Optgen to express the structure of<br>transformations, along with a tool that generates production Go code from that DSL. Here is an example<br>of a transformation expressed in the Optgen language:<br>截至目前，基于成本的优化器实现了超过160种不同的转换，而且我们希望在未来的版本中增加更多的转换。<br>因为转换是新优化器的核心，我们花了很多时间使它们尽可能容易定义、理解和维护。<br>为此，我们创建了一种叫做Optgen的特定领域语言（DSL）来表达转换的结构，同时还有一个工具可以从DSL中生成Go代码。<br>下面是一个用Optgen语言表达的转换实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[MergeSelectInnerJoin, Normalize]</span><br><span class="line">(Select</span><br><span class="line">$input:(InnerJoin $left:* $right:* $on:*)</span><br><span class="line">$filter:*</span><br><span class="line">)</span><br><span class="line">=&gt;</span><br><span class="line">(InnerJoin</span><br><span class="line">$left</span><br><span class="line">$right</span><br><span class="line">(ConcatFilters $on $filter)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>This transformation merges conditions from a WHERE clause with conditions from the ON clause<br>of an INNER JOIN. It generates ~25 lines of Go code, including code to ensure that transitively<br>matching transformations are applied. A future blog post will delve into more Optgen specifics,<br>as there’s a lot there to cover. If you can’t wait for that, take a look at the <a href="https://github.com/cockroachdb/cockroach/blob/master/pkg/sql/opt/optgen/lang/doc.go">documentation for<br>Optgen</a>.<br>You might also take a look at some of our <a href="https://github.com/cockroachdb/cockroach/tree/master/pkg/sql/opt/norm/rules">transformation definition files</a>.<br>If you’re especially ambitious, try your hand at crafting a new transformation that we’re missing;<br>we always welcome community contributions.<br>这个转换将WHERE子句的条件与INNER JOIN的ON子句的条件合并。<br>它产生了大约25行的Go代码，包括确保应用过渡匹配转换的代码。<br>未来的一篇博文将深入探讨更多Optgen的细节，因为那里有很多东西要介绍。<br>如果你等不及了，可以看看[Optgen的文档]。<br>你也可以看看我们的一些[转换定义文件]。<br>如果你特别有雄心壮志，可以尝试制作一个我们所缺少的新的变换。我们总是欢迎社区的贡献。</p>
<h3 id="The-Memo"><a href="#The-Memo" class="headerlink" title="The Memo"></a>The Memo</h3><p>I’ve explained how the optimizer generates many equivalent plans and uses a cost estimate to choose<br>from among them. That sounds good in theory, but what about the practical side of things? Doesn’t it<br>take a potentially exponential amount of memory to store all those plans? The answer involves an<br>ingenious data structure called a memo.<br>我已经解释了优化器是如何生成许多等价的计划，并使用成本估算来从这些计划中进行选择。<br>这在理论上听起来不错，但实际情况如何呢？难道它不需要一个潜在的指数级的内存来存储所有这些计划吗？<br>答案是涉及一种巧妙的数据结构，称为备忘录。</p>
<p>A memo is designed to efficiently store a forest of plan trees for a given query by exploiting the<br>significant redundancies across the plans. For example, a join query could have several logically<br>equivalent plans that are identical in all ways, except that one plan uses a hash join, another uses<br>a merge join, and the third uses a lookup join. Furthermore, each of those plans could in turn have<br>several variants: in one variant, the left join input uses the primary index to scan rows, and in<br>another variant it uses a secondary index to do the equivalent work. Encoded naively, the resulting<br>exponential explosion of plans would require exponential memory to store.<br>备忘录被设计为通过利用计划间的显著冗余来有效地存储一个给定查询的计划树森林。<br>例如，一个连接查询可能有几个逻辑上相等的计划，这些计划在所有方面都是相同的，除了一个计划使用哈希连接，另一个使用合并连接，而第三个使用查找连接。<br>此外，这些计划中的每一个又可以有几个变体：在一个变体中，左边的连接输入使用主索引来扫描行，而在另一个变体中，它使用一个二级索引来做等价的工作。<br>如果以最初的形式编码，所产生的指数级爆炸的计划将需要指数级的内存来存储。</p>
<p>The memo tackles this problem by defining a set of equivalence classes called memo groups, where each<br>group contains a set of logically equivalent expressions. Here is an illustration:<br>备忘录通过定义一组称为备忘录组的等价类来解决这个问题，其中每个组包含一组逻辑上等价的表达式。下面是一个例子。</p>
<p><img src="/img/images_optimizer/memo.png"></p>
<p>To build a plan, pick any operator from group #1, then pick its left input from group #2 and its right<br>input from group #3. No matter which you pick, you have a legal plan, since operators in the same group<br>are guaranteed to be logically equivalent. Simple arithmetic reveals that there are 12 possible plans<br>(3 * 2 * 2) encoded in this memo. Now imagine a complex reporting query with a 6-way join, complex aggregation,<br>and lots of filter conditions. The number of plans might number in the thousands, and yet would be encoded<br>in much less space than you would expect if you weren’t aware of the memo structure.<br>要建立一个计划，从1号组中挑选任何运算符，然后从2号组中挑选其左边的输入，从3号组中挑选其右边的输入。<br>无论你选哪一个，你都有一个合法的计划，因为同一组的运算符保证在逻辑上是等价的。<br>简单的算术显示，有12个可能的计划（3<em>2</em>2）在这个备忘录中被编码。<br>现在想象一下，一个复杂的报告查询，有一个6路连接，复杂的聚合，以及很多过滤条件。<br>计划的数量可能有几千种，但是如果你不知道备忘录的结构，那么编码的空间会比你预期的少得多。</p>
<p>Of course the optimizer does not just randomly pick one of the possible plan trees from the memo.<br>Instead, it tracks the lowest cost expression in each memo group, and then recursively constructs<br>the final plan from those expressions. Indeed, the memo is a beautiful data structure, reminding me of<br>the illuminati diamond ambigram from Dan Brown’s novel “Angels and Demons”. Both encode more information<br>than seems possible.<br>当然，优化器并不只是随机地从备忘录中挑选一个可能的计划树。<br>相反，它追踪每个备忘录组中成本最低的表达式，然后从这些表达式中递归地构建最终计划。<br>事实上，备忘录是一个美丽的数据结构，让我想起了丹-布朗的小说《天使与魔鬼》中的光照派钻石伏线图。<br>两者都编码了比看起来更多的信息。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> opt</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">官方文档</span></span><br><span class="line"><span class="comment">https://www.cockroachlabs.com/blog/building-cost-based-sql-optimizer/</span></span><br><span class="line"><span class="comment">知乎优秀网址</span></span><br><span class="line"><span class="comment">https://zhuanlan.zhihu.com/p/73545345</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 读pkg/sql/opt/doc.go</span></span><br><span class="line"><span class="comment">Package opt contains the Cockroach SQL optimizer. The optimizer transforms the</span></span><br><span class="line"><span class="comment">AST of a SQL query into a physical query plan for execution. Naive execution of</span></span><br><span class="line"><span class="comment">a SQL query can be prohibitively expensive, because SQL specifies the desired</span></span><br><span class="line"><span class="comment">results and not how to achieve them. A given SQL query can have thousands of</span></span><br><span class="line"><span class="comment">equivalent query plans with vastly different execution times. The Cockroach</span></span><br><span class="line"><span class="comment">optimizer is cost-based, meaning that it enumerates some or all of these</span></span><br><span class="line"><span class="comment">alternate plans and chooses the one with the lowest estimated cost.</span></span><br><span class="line"><span class="comment">opt包 包括cockroach sql optimizer。</span></span><br><span class="line"><span class="comment">优化器将sql查询的ast转化为执行器的物理查询计划。</span></span><br><span class="line"><span class="comment">自然地执行一个sql查询大概是非常高昂的，因为sql指定的是所需的结果而不是如何实现这些结果。</span></span><br><span class="line"><span class="comment">一个给定的sql查询有成千上万哥等价的查询计划，其执行时间有很大的不同。</span></span><br><span class="line"><span class="comment">cockroach的优化器是基于代价的，这以为这它列举了一些或者全部等价的计划，然后选择其中一个预估代价最低的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Overview</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SQL query planning is often described in terms of 8 modules:</span></span><br><span class="line"><span class="comment">sql查询计划通常在通过8种模型来描述：</span></span><br><span class="line"><span class="comment">1. Properties</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. Stats</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Cost Model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. Memo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. Transforms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. Prep</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. Rewrite</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8. Search</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note Prep, Rewrite and Search could be considered phases, though this document</span></span><br><span class="line"><span class="comment">will refer to all 8 uniformly as modules. Memo is a technique for compactly</span></span><br><span class="line"><span class="comment">representing the forest of trees generated during Search. Stats, Properties,</span></span><br><span class="line"><span class="comment">Cost Model and Transformations are modules that power the Prep, Rewrite and</span></span><br><span class="line"><span class="comment">Search phases.</span></span><br><span class="line"><span class="comment">注意 Prep、Rewrite、Search可以被认为是阶段性的，尽管本文件将所有8个模块统一称为模块。</span></span><br><span class="line"><span class="comment">memo是一种技术，用于紧凑地表示search过程中产生的树木森林。</span></span><br><span class="line"><span class="comment">stats、properties、cost model和transformations是支持prep、rewrite和search阶段的模块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                       SQL query text</span></span><br><span class="line"><span class="comment">                             |</span></span><br><span class="line"><span class="comment">                       +-----v-----+  - parse SQL text according to grammar</span></span><br><span class="line"><span class="comment">                       |   Parse   |  - report syntax errors</span></span><br><span class="line"><span class="comment">                       +-----+-----+</span></span><br><span class="line"><span class="comment">                             |</span></span><br><span class="line"><span class="comment">                           (ast)</span></span><br><span class="line"><span class="comment">                             |</span></span><br><span class="line"><span class="comment">                       +-----v-----+  - fold constants, check types, resolve</span></span><br><span class="line"><span class="comment">                       |  Analyze  |    names</span></span><br><span class="line"><span class="comment">                       +-----+-----+  - annotate tree with semantic info</span></span><br><span class="line"><span class="comment">                             |        - report semantic errors</span></span><br><span class="line"><span class="comment">                           (ast+)</span></span><br><span class="line"><span class="comment">         +-------+           |</span></span><br><span class="line"><span class="comment">         | Stats +-----&gt;-----v-----+  - normalize tree with cost-agnostic</span></span><br><span class="line"><span class="comment">         +-------+     |   Prep    |    transforms (placeholders present)</span></span><br><span class="line"><span class="comment">                    +--&gt;-----+-----+  - compute initial properties</span></span><br><span class="line"><span class="comment">                    |        |        - retrieve and attach stats</span></span><br><span class="line"><span class="comment">                    |     (expr)      - done once per PREPARE</span></span><br><span class="line"><span class="comment">                    |        |</span></span><br><span class="line"><span class="comment">    +------------+  |  +-----v-----+  - capture placeholder values / timestamps</span></span><br><span class="line"><span class="comment">    | Transforms |--+--&gt;  Rewrite  |  - normalize tree with cost-agnostic</span></span><br><span class="line"><span class="comment">    +------------+  |  +-----+-----+    transforms (placeholders not present)</span></span><br><span class="line"><span class="comment">                    |        |        - done once per EXECUTE</span></span><br><span class="line"><span class="comment">                    |     (expr)</span></span><br><span class="line"><span class="comment">                    |        |</span></span><br><span class="line"><span class="comment">                    +--&gt;-----v-----+  - generate equivalent expression trees</span></span><br><span class="line"><span class="comment">    +------------+     |  Search   |  - find lowest cost physical plan</span></span><br><span class="line"><span class="comment">    | Cost Model +-----&gt;-----+-----+  - includes DistSQL physical planning</span></span><br><span class="line"><span class="comment">    +------------+           |</span></span><br><span class="line"><span class="comment">                      (physical plan)</span></span><br><span class="line"><span class="comment">                             |</span></span><br><span class="line"><span class="comment">                       +-----v-----+</span></span><br><span class="line"><span class="comment">                       | Execution |</span></span><br><span class="line"><span class="comment">                       +-----------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The opt-related packages implement portions of these modules, while other parts</span></span><br><span class="line"><span class="comment">are implemented elsewhere. For example, other sql packages are used to perform</span></span><br><span class="line"><span class="comment">name resolution and type checking which are part of the Analyze phase.</span></span><br><span class="line"><span class="comment">opt相关的包实现了这些模块的部分内容，而其他部分则在其他地方实现。</span></span><br><span class="line"><span class="comment">例如，其他sql包被用来执行名称解析和类型检查，这是Analyze阶段的一部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Parse</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The parse phase is not discussed in this document. It transforms the SQL query</span></span><br><span class="line"><span class="comment">text into an abstract syntax tree (AST).</span></span><br><span class="line"><span class="comment">parser阶段在本文件中没有讨论。它将sql查询语句转化成一个抽象的语法树（AST）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Analyze</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The analyze phase ensures that the AST obeys all SQL semantic rules, and</span></span><br><span class="line"><span class="comment">annotates the AST with information that will be used by later phases. In</span></span><br><span class="line"><span class="comment">addition, some simple transforms are applied to the AST in order to simplify</span></span><br><span class="line"><span class="comment">handling in later phases. Semantic rules are many and varied; this document</span></span><br><span class="line"><span class="comment">describes a few major categories of semantic checks and rewrites.</span></span><br><span class="line"><span class="comment">analyze阶段确保ast遵守了所有的sql语义规则，并且在ast树上标注了后续阶段将被使用的信息。</span></span><br><span class="line"><span class="comment">此外，ast树中也可以做一些简单的转换，以便在后续阶段对它做简单处理。</span></span><br><span class="line"><span class="comment">语意规则是多种多样的；这个文件描述了语义检查和重写的几个主要类别。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Name resolution&quot; binds table, column, and other references. Each name must be</span></span><br><span class="line"><span class="comment">matched to the appropriate schema object, and an error reported if no matching</span></span><br><span class="line"><span class="comment">object can be found. Name binding can result in AST annotations that make it</span></span><br><span class="line"><span class="comment">easy for other components to find the target object, or rewrites that replace</span></span><br><span class="line"><span class="comment">unbound name nodes with new nodes that are easier to handle (e.g. IndexedVar).</span></span><br><span class="line"><span class="comment">&quot;名称解析 &quot;绑定了表、列和其他引用。每个名字都必须与适当的模式对象相匹配，如果找不到匹配的对象，则会报告错误。</span></span><br><span class="line"><span class="comment">名称绑定可以导致AST注释，使其他组件很容易找到目标对象，或者重写，用更容易处理的新节点替换未绑定的名称节点（例如IndexedVar）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Constant folding&quot; rewrites expressions that have constant inputs. For example,</span></span><br><span class="line"><span class="comment">1+1 would be folded to 2. Cockroach&#x27;s typing rules assume that constants have</span></span><br><span class="line"><span class="comment">been folded, as there are some expressions that would otherwise produce a</span></span><br><span class="line"><span class="comment">semantic error if they are not first folded.</span></span><br><span class="line"><span class="comment">&quot;常量折叠&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Type inference&quot; automatically determines the return data type of various SQL</span></span><br><span class="line"><span class="comment">expressions, based on the types of inputs, as well as the context in which the</span></span><br><span class="line"><span class="comment">expression is used. The AST is annotated with the resolved types for later use.</span></span><br><span class="line"><span class="comment">&quot;类型推理&quot;自动确定各种SQL表达式的返回数据类型，其依据是输入的类型以及表达式的使用环境。</span></span><br><span class="line"><span class="comment">AST被注释为已解决的类型，供以后使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Type checking&quot; ensures that all inputs to SQL expressions and statements have</span></span><br><span class="line"><span class="comment">legal static types. For example, the CONCAT function only accepts zero or more</span></span><br><span class="line"><span class="comment">arguments that are statically typed as strings. Violation of the typing rules</span></span><br><span class="line"><span class="comment">produces a semantic error.</span></span><br><span class="line"><span class="comment">&quot;类型检查&quot;确保SQL表达式和语句的所有输入具有合法的静态类型。</span></span><br><span class="line"><span class="comment">例如，CONCAT函数只接受静态类型为字符串的零或多个参数。违反类型规则产生一个语义错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Properties</span></span><br><span class="line"><span class="comment">属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Properties are meta-information that are computed (and sometimes stored) for</span></span><br><span class="line"><span class="comment">each node in an expression. Properties power transformations and optimization.</span></span><br><span class="line"><span class="comment">属性是为表达式中的每个节点计算（有时还存储）的元信息。</span></span><br><span class="line"><span class="comment">属性为转换和优化提供动力。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Logical properties&quot; describe the structure and content of data returned by an</span></span><br><span class="line"><span class="comment">expression, such as whether relational output columns can contain nulls, or the</span></span><br><span class="line"><span class="comment">data type of a scalar expression. Two expressions which are logically</span></span><br><span class="line"><span class="comment">equivalent according to the rules of the relational algebra will return the</span></span><br><span class="line"><span class="comment">same set of rows and columns, and will have the same set of logical properties.</span></span><br><span class="line"><span class="comment">However, the order of the rows, naming of the columns, and other presentational</span></span><br><span class="line"><span class="comment">aspects of the result are not governed by the logical properties.</span></span><br><span class="line"><span class="comment">&quot;逻辑属性&quot;描述了由表达式返回的数据的结构和内容，例如关系输出列是否可以包含空值，或者标量表达式的数据类型。</span></span><br><span class="line"><span class="comment">根据关系代数的规则，两个在逻辑上等同的表达式将返回的行和列的集合，并具有相同的逻辑属性。</span></span><br><span class="line"><span class="comment">然而，行的顺序、列的命名以及结果的其他表现形式并不受逻辑属性的制约。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Physical properties&quot; are interesting characteristics of an expression that</span></span><br><span class="line"><span class="comment">impact its layout, presentation, or location, but not its logical content.</span></span><br><span class="line"><span class="comment">Examples include row order, column naming, and data distribution (physical</span></span><br><span class="line"><span class="comment">location of data ranges). Physical properties exist outside of the relational</span></span><br><span class="line"><span class="comment">algebra, and arise from both the SQL query itself (e.g. the non-relational</span></span><br><span class="line"><span class="comment">ORDER BY operator) and by the selection of specific implementations during</span></span><br><span class="line"><span class="comment">optimization (e.g. a merge join requires the inputs to be sorted in a</span></span><br><span class="line"><span class="comment">particular order).</span></span><br><span class="line"><span class="comment">&quot;物理属性&quot;是表达式的有趣特征，影响其布局、演示或位置，但不影响其逻辑内容。</span></span><br><span class="line"><span class="comment">例子包括行顺序、列命名和数据分布（数据范围的物理位置）。</span></span><br><span class="line"><span class="comment">物理属性存在于关系代数之外，产生于SQL查询本身（比如非关系型的ORDER BY操作符）和在优化过程中对特定实现的选择（比如合并连接要求输入以特定顺序排序）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Properties can be &quot;required&quot; or &quot;derived&quot;. A required property is one specified</span></span><br><span class="line"><span class="comment">by the SQL query text. For example, a DISTINCT clause is a required property on</span></span><br><span class="line"><span class="comment">the set of columns of the corresponding projection -- that the tuple of columns</span></span><br><span class="line"><span class="comment">forms a key (unique values) in the results. A derived property is one derived</span></span><br><span class="line"><span class="comment">by the optimizer for an expression based on the properties of the child</span></span><br><span class="line"><span class="comment">expressions. For example:</span></span><br><span class="line"><span class="comment">属性可以是&quot;必需的&quot;或&quot;派生的&quot;。一个必需的属性是由SQL查询文本指定的。</span></span><br><span class="line"><span class="comment">例如，DISTINCT子句是相应的投影的列集上的一个必需属性 -- 列的元组在结果中形成一个键（唯一的值）。</span></span><br><span class="line"><span class="comment">派生属性是由优化器根据子表达式的属性为表达式派生的属性。比如说：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SELECT k+1 FROM kv</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Once the ordering of &quot;k&quot; is known from kv&#x27;s descriptor, the same ordering</span></span><br><span class="line"><span class="comment">property can be derived for k+1. During optimization, for each expression with</span></span><br><span class="line"><span class="comment">required properties, the optimizer will look at child expressions to check</span></span><br><span class="line"><span class="comment">whether their actual properties (which can be derived) match the requirement.</span></span><br><span class="line"><span class="comment">If they don&#x27;t, the optimizer must introduce an &quot;enforcer&quot; operator in the plan</span></span><br><span class="line"><span class="comment">that provides the required property. For example, an ORDER BY clause creates a</span></span><br><span class="line"><span class="comment">required ordering property that can cause the optimizer to add a Sort operator</span></span><br><span class="line"><span class="comment">as an enforcer of that property.</span></span><br><span class="line"><span class="comment">一旦从kv的描述符中知道了&quot;k&quot;的排序，就可以为k+1导出同样的排序属性。</span></span><br><span class="line"><span class="comment">在优化过程中，对于每个具有所需属性的表达式，优化器将查看子表达式，以检查它们的实际属性（可以导出）是否符合要求。</span></span><br><span class="line"><span class="comment">如果它们不符合，优化器必须在计划中引入一个提供所需属性的&quot;执行者&quot;操作符。</span></span><br><span class="line"><span class="comment">例如，ORDER BY子句创建了一个所需的排序属性，可以使优化器添加一个排序操作符作为该属性的执行者。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Stats</span></span><br><span class="line"><span class="comment">统计信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Table statistics power both the cost model and the search of alternate query</span></span><br><span class="line"><span class="comment">plans. A simple example of where statistics guide the search of alternate query</span></span><br><span class="line"><span class="comment">plans is in join ordering:</span></span><br><span class="line"><span class="comment">表统计信息在代价模型和选择查询计划之前起作用。一个简单的例子显示统计信息在搜寻join顺序中的选择查询计划中的指导。</span></span><br><span class="line"><span class="comment">SELECT * FROM a JOIN b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In the absence of other opportunities, this might be implemented as a hash</span></span><br><span class="line"><span class="comment">join. With a hash join, we want to load the smaller set of rows (either from a</span></span><br><span class="line"><span class="comment">or b) into the hash table and then query that table while looping through the</span></span><br><span class="line"><span class="comment">larger set of rows. How do we know whether a or b is larger? We keep statistics</span></span><br><span class="line"><span class="comment">about the cardinality of a and b, i.e. the (approximate) number of different</span></span><br><span class="line"><span class="comment">values.</span></span><br><span class="line"><span class="comment">当没有其他选项时，大概会作为hash join去执行。使用hash join时，我们希望将较小的行集（从a或者b中）载入哈希表中，然后</span></span><br><span class="line"><span class="comment">浏览较大行集时查询该表。我们怎么知道a还是b是更大的呢？我们保持统计关于a和b的cardinality，即不同值的（近似）数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Simple table cardinality is sufficient for the above query but fails in other</span></span><br><span class="line"><span class="comment">queries. Consider:</span></span><br><span class="line"><span class="comment">对于以上查询 简单的表的cardinality是足够的，但是在其他查询中却会失败，考虑到：</span></span><br><span class="line"><span class="comment">SELECT * FROM a JOIN b ON a.x = b.x WHERE a.y &gt; 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Table statistics might indicate that a contains 10x more data than b, but the</span></span><br><span class="line"><span class="comment">predicate a.y &gt; 10 is filtering a chunk of the table. What we care about is</span></span><br><span class="line"><span class="comment">whether the result of the scan *after* filtering returns more rows than the</span></span><br><span class="line"><span class="comment">scan of b. This can be accomplished by making a determination of the</span></span><br><span class="line"><span class="comment">selectivity of the predicate a.y &gt; 10 (the % of rows it will filter) and then</span></span><br><span class="line"><span class="comment">multiplying that selectivity by the cardinality of a. The common technique for</span></span><br><span class="line"><span class="comment">estimating selectivity is to collect a histogram on a.y.</span></span><br><span class="line"><span class="comment">表的统计信息表名，a的数据量是b的十倍，但是谓词 a.y &gt; 10 正在过滤表的一个块。我们关心的是a过滤之后返回的行集的扫描结果是否比b的扫描结果更大。</span></span><br><span class="line"><span class="comment">这可以通过确定谓词a.y &gt; 10的选择性（它将过滤的行的百分比）来实现，然后将这个选择性乘以a的cardinality。</span></span><br><span class="line"><span class="comment">估计选择性的常用技术是收集a.y的柱状图。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The collection of table statistics occurs prior to receiving the query. As</span></span><br><span class="line"><span class="comment">such, the statistics are necessarily out of date and may be inaccurate. The</span></span><br><span class="line"><span class="comment">system may bound the inaccuracy by recomputing the stats based on how fast a</span></span><br><span class="line"><span class="comment">table is being modified. Or the system may notice when stat estimations are</span></span><br><span class="line"><span class="comment">inaccurate during query execution.</span></span><br><span class="line"><span class="comment">表统计信息的手机发生在接收查询之前。因为，统计信息必然是果实的，可能会不准确。系统大概会根据表被修改的速度更新统计信息，</span></span><br><span class="line"><span class="comment">从而约束统计信息不准确的情况。或者当系统注意到查询执行期间统计估计不准确的时候</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Cost Model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The cost model takes an expression as input and computes an estimated &quot;cost&quot;</span></span><br><span class="line"><span class="comment">to execute that expression. The unit of &quot;cost&quot; can be arbitrary, though it is</span></span><br><span class="line"><span class="comment">desirable if it has some real world meaning such as expected execution time.</span></span><br><span class="line"><span class="comment">What is required is for the costs of different query plans to be comparable.</span></span><br><span class="line"><span class="comment">The optimizer seeks to find the shortest expected execution time for a query</span></span><br><span class="line"><span class="comment">and uses cost as a proxy for execution time.</span></span><br><span class="line"><span class="comment">代价模型将一个表达式作为输入，然后计算出执行该表达式的估算成本。成本的单位可以是任意的，但是如果它具有一些现实世界的意义就是可取的，</span></span><br><span class="line"><span class="comment">例如预计执行时间。所需要的就是不同查询计划的代价具有可比性。优化器试图为一个查询找到最短的预期执行时间，</span></span><br><span class="line"><span class="comment">并且将这个代价作为执行时间的代理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Cost is roughly calculated by estimating how much time each node in the</span></span><br><span class="line"><span class="comment">expression tree will use to process all results and modeling how data flows</span></span><br><span class="line"><span class="comment">through the expression tree. Table statistics are used to power cardinality</span></span><br><span class="line"><span class="comment">estimates of base relations which in term power cardinality estimates of</span></span><br><span class="line"><span class="comment">interimg/images_optimizerte relations. This is accomplished by propagating histograms of</span></span><br><span class="line"><span class="comment">column values from base relations up through interimg/images_optimizerte nodes (e.g. combining</span></span><br><span class="line"><span class="comment">histograms from the two join inputs into a single histogram). Operator-specific</span></span><br><span class="line"><span class="comment">computations model the network, disk and CPU costs. The cost model should</span></span><br><span class="line"><span class="comment">include data layout and the specific operating environment. For example,</span></span><br><span class="line"><span class="comment">network RTT in one cluster might be vastly different than another.</span></span><br><span class="line"><span class="comment">代价是通过来预估表达式中的每个节点处理所有结果所需要的时间，并对数据在表达式树内如何流动进行建模而粗略计算的。</span></span><br><span class="line"><span class="comment">表的统计信息被用来增强基准关系的基数估计，这在术语中是增强对中间关系的基数估计。</span></span><br><span class="line"><span class="comment">这是通过传播从基础关系到中间关系的列值的直方图来实现的。</span></span><br><span class="line"><span class="comment">列值的直方图通过中间节点向上传播（例如，将两个join 的直方图结合成一个直方图）。</span></span><br><span class="line"><span class="comment">具体操作计算 对网络、磁盘和CPU成本进行建模。</span></span><br><span class="line"><span class="comment">该成本模型应包括数据布局和具体操作环境。例如。一个集群中的网络RTT可能与另一个集群有很大的不同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Because the cost for a query plan is an estimate, there is an associated error.</span></span><br><span class="line"><span class="comment">This error might be implicit in the cost, or could be explicitly tracked. One</span></span><br><span class="line"><span class="comment">advantage to explicitly tracking the expected error is that it can allow</span></span><br><span class="line"><span class="comment">selecting a higher cost but lower expected error plan over a lower cost but</span></span><br><span class="line"><span class="comment">higher expected error plan. Where does the error come from? One source is the</span></span><br><span class="line"><span class="comment">innate inaccuracy of stats: selectivity estimation might be wildly off due to</span></span><br><span class="line"><span class="comment">an outlier value. Another source is the accumulated build up of estimation</span></span><br><span class="line"><span class="comment">errors the higher up in the query tree. Lastly, the cost model is making an</span></span><br><span class="line"><span class="comment">estimation for the execution time of an operation such as a network RTT. This</span></span><br><span class="line"><span class="comment">estimate can also be wildly inaccurate due to bursts of activity.</span></span><br><span class="line"><span class="comment">因为查询计划的成本是一种估计，所以有一个相关的误差。</span></span><br><span class="line"><span class="comment">这个误差可能隐含在成本中，也可能被明确地追踪到。</span></span><br><span class="line"><span class="comment">一个 明确跟踪预期误差的一个好处是，它可以允许选择一个成本较高但预期误差较低的计划，而不是成本较低但 高预期误差的计划。</span></span><br><span class="line"><span class="comment">误差从何而来？一个来源是 统计的先天不准确性：由于离散值的存在，选择性的估计可能会出现巨大的偏差。</span></span><br><span class="line"><span class="comment">另一个来源是估计的积累误差的积累。最后，成本模型是对估算一个操作的执行时间，如网络RTT。</span></span><br><span class="line"><span class="comment">由于活动的突发，这种估计也可能是非常不准确的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Search finds the lowest cost plan using dynamic programming. That imposes a</span></span><br><span class="line"><span class="comment">restriction on the cost model: it must exhibit optimal substructure. An optimal</span></span><br><span class="line"><span class="comment">solution can be constructed from optimal solutions of its sub-problems.</span></span><br><span class="line"><span class="comment">搜索使用动态编程找到成本最低的计划。</span></span><br><span class="line"><span class="comment">这对成本模型施加了一个限制：它必须表现出最优的子结构。</span></span><br><span class="line"><span class="comment">一个最优的解决方案可以由其子问题的最优解决方案构建。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Memo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Memo is a data structure for efficiently storing a forest of query plans.</span></span><br><span class="line"><span class="comment">Conceptually, the memo is composed of a numbered set of equivalency classes</span></span><br><span class="line"><span class="comment">called groups where each group contains a set of logically equivalent</span></span><br><span class="line"><span class="comment">expressions. The different expressions in a single group are called memo</span></span><br><span class="line"><span class="comment">expressions (memo-ized expressions). A memo expression has a list of child</span></span><br><span class="line"><span class="comment">groups as its children rather than a list of individual expressions. The</span></span><br><span class="line"><span class="comment">forest is composed of every possible combination of parent expression with</span></span><br><span class="line"><span class="comment">its children, recursively applied.</span></span><br><span class="line"><span class="comment">Memo是一种数据结构，用于有效地存储查询计划的森林。</span></span><br><span class="line"><span class="comment">从概念上讲，备忘录是由一组编号的等价类组成的，称为组，其中每个组包含一组逻辑上等价的表达。</span></span><br><span class="line"><span class="comment">单个组中的不同表达式被称为备忘录表达式（memo-ized expressions）。一个备忘录表达式有一个子组的列表作为其子女，</span></span><br><span class="line"><span class="comment">而不是一个单独的表达式的列表。森林是由父表达式与它的子表达式的每一个可能的组合组成的。递归地应用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Memo expressions can be relational (e.g. join) or scalar (e.g. &lt;). Operators</span></span><br><span class="line"><span class="comment">are always both logical (specify results) and physical (specify results and a</span></span><br><span class="line"><span class="comment">particular implementation). This means that even a &quot;raw&quot; unoptimized expression</span></span><br><span class="line"><span class="comment">tree can be executed (naively). Both relational and scalar operators are</span></span><br><span class="line"><span class="comment">uniformly represented as nodes in memo expression trees, which facilitates tree</span></span><br><span class="line"><span class="comment">pattern matching and replacement.</span></span><br><span class="line"><span class="comment">备忘录表达式可以是关系型的（如join）或标量型的（如&lt;）。</span></span><br><span class="line"><span class="comment">操作符总是既是逻辑性的（指定结果）又是物理性的（指定结果和一个特定的实现）。</span></span><br><span class="line"><span class="comment">这意味着，即使是一个&quot;原始的 &quot;未优化的表达式树也可以被执行（自然地）。</span></span><br><span class="line"><span class="comment">关系型和标量型操作符都是统一表示为备忘录表达式树中的节点，这方便树的模式匹配和替换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Because memo groups contain logically equivalent expressions, all the memo</span></span><br><span class="line"><span class="comment">expressions in a group share the same logical properties. However, it&#x27;s</span></span><br><span class="line"><span class="comment">possible for two logically equivalent expressions to be placed in different</span></span><br><span class="line"><span class="comment">memo groups. This occurs because determining logical equivalency of two</span></span><br><span class="line"><span class="comment">relational expressions is too complex to perform 100% correctly. A correctness</span></span><br><span class="line"><span class="comment">failure (i.e. considering two expressions logically equivalent when they are</span></span><br><span class="line"><span class="comment">not) results in invalid transformations and invalid plans. But placing two</span></span><br><span class="line"><span class="comment">logically equivalent expressions in different groups has a much gentler failure</span></span><br><span class="line"><span class="comment">mode: the memo and transformations are less efficient. Expressions within the</span></span><br><span class="line"><span class="comment">memo may have different physical properties. For example, a memo group might</span></span><br><span class="line"><span class="comment">contain both hash join and merge join expressions which produce the same set of</span></span><br><span class="line"><span class="comment">output rows, but produce them in different orders.</span></span><br><span class="line"><span class="comment">因为备忘录组包含逻辑上相等的表达式，所以一个组中的所有备忘录表达式共享相同的逻辑属性。</span></span><br><span class="line"><span class="comment">然而，有可能两个逻辑上相等的表达式被放在不同的备忘录组。</span></span><br><span class="line"><span class="comment">出现这种情况的原因是，确定两个关系表达式的逻辑等价性过于复杂，无法100%正确执行。</span></span><br><span class="line"><span class="comment">一次正确性故障（即认为两个表达式在逻辑上是等价的，但它们不是）导致无效的转换和无效的计划。</span></span><br><span class="line"><span class="comment">但是将两个将两个逻辑上等价的表达式放在不同的组中，有一个温和得多的故障模式：备忘录和转换的效率较低。</span></span><br><span class="line"><span class="comment">表达式在备忘录可能有不同的物理属性。</span></span><br><span class="line"><span class="comment">例如，一个备忘录组可能包含哈希连接和合并连接表达式，这些表达式产生相同的输出行，但是以不同的顺序产生它们。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expressions are inserted into the memo by the factory, which ensure that</span></span><br><span class="line"><span class="comment">expressions have been fully normalized before insertion (see the Prep section</span></span><br><span class="line"><span class="comment">for more details). A new group is created only when unique normalized</span></span><br><span class="line"><span class="comment">expressions are created by the factory during construction or rewrite of the</span></span><br><span class="line"><span class="comment">tree. Uniqueness is determined by computing the fingerprint for a memo</span></span><br><span class="line"><span class="comment">expression, which is simply the expression operator and its list of child</span></span><br><span class="line"><span class="comment">groups. For example, consider this query:</span></span><br><span class="line"><span class="comment">表达式是由factory插入到备忘录中的，它确保表达式在插入之前已经被完全规范化了。</span></span><br><span class="line"><span class="comment">只有当factory在构建或重写树的过程在插入过程中创建了唯一的规范化表达式时，才会创建一个新的组。</span></span><br><span class="line"><span class="comment">唯一性是通过计算备忘录的指纹（只是表达式运算符和它的子组列表）来确定。</span></span><br><span class="line"><span class="comment">例如，考虑这个查询：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">SELECT * FROM a, b WHERE a.x = b.x</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">After insertion into the memo, the memo would contain these six groups:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6: [inner-join [1 2 5]]</span></span><br><span class="line"><span class="comment">5: [eq [3 4]]</span></span><br><span class="line"><span class="comment">4: [variable b.x]</span></span><br><span class="line"><span class="comment">3: [variable a.x]</span></span><br><span class="line"><span class="comment">2: [scan b]</span></span><br><span class="line"><span class="comment">1: [scan a]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The fingerprint for the inner-join expression is [inner-join [1 2 5]]. The</span></span><br><span class="line"><span class="comment">memo maintains a map from expression fingerprint to memo group which allows</span></span><br><span class="line"><span class="comment">quick determination of whether the normalized form of an expression already</span></span><br><span class="line"><span class="comment">exists in the memo.</span></span><br><span class="line"><span class="comment">内部连接表达式的指纹是[inner-join [1 2 5]]。</span></span><br><span class="line"><span class="comment">备忘录维护着一个从表达式指纹到备忘录组的映射，它允许快速确定一个表达式的规范化形式是否已经存在于备忘录中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The normalizing factory will never add more than one expression to a memo</span></span><br><span class="line"><span class="comment">group. But the explorer (see Search section for more details) does add</span></span><br><span class="line"><span class="comment">denormalized expressions to existing memo groups, since oftentimes one of these</span></span><br><span class="line"><span class="comment">equivalent, but denormalized expressions will have a lower cost than the</span></span><br><span class="line"><span class="comment">initial normalized expression added by the factory. For example, the join</span></span><br><span class="line"><span class="comment">commutativity transformation expands the memo like this:</span></span><br><span class="line"><span class="comment">normalizing factory决不会向一个备忘录组添加一个以上的表达式。</span></span><br><span class="line"><span class="comment">但是探索器（详见Search部分）会将已被规范化的表达式添加到现有的备忘录组中，</span></span><br><span class="line"><span class="comment">因为通常情况下，这些表达式中的一个等价的、但已被规范化的表达式将比factory添加的初始规范化表达式有更低的成本。</span></span><br><span class="line"><span class="comment">例如，join的交换性转换是这样扩展备忘录的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6: [inner-join [1 2 5]] [inner-join [2 1 5]]</span></span><br><span class="line"><span class="comment">5: [eq [3 4]]</span></span><br><span class="line"><span class="comment">4: [variable b.x]</span></span><br><span class="line"><span class="comment">3: [variable a.x]</span></span><br><span class="line"><span class="comment">2: [scan b]</span></span><br><span class="line"><span class="comment">1: [scan a]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Notice that there are now two expressions in memo group 6. The coster (see Cost</span></span><br><span class="line"><span class="comment">Model section for more details) will estimate the execution cost of each</span></span><br><span class="line"><span class="comment">expression, and the optimizer will select the lowest cost alternative.</span></span><br><span class="line"><span class="comment">注意，现在有两个表达式在备忘录组6中。 Coster（详见Cost模型部分）将估计每个表达式的执行成本，而optimizer将选择成本最低的替代方案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Transforms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Transforms convert an input expression tree into zero or more logically</span></span><br><span class="line"><span class="comment">equivalent trees. Transforms consist of two parts: a &quot;match pattern&quot; and a</span></span><br><span class="line"><span class="comment">&quot;replace pattern&quot;. Together, the match pattern and replace pattern are called a</span></span><br><span class="line"><span class="comment">&quot;rule&quot;. Transform rules are categorized as &quot;normalization&quot; or &quot;exploration&quot;</span></span><br><span class="line"><span class="comment">rules.</span></span><br><span class="line"><span class="comment">转换将一个输入的表达式树转换为零个或多个逻辑上的等价树。</span></span><br><span class="line"><span class="comment">转换由两部分组成：一个 &quot;匹配模式&quot;和一个 &quot;替换模式&quot;。匹配模式和替换模式一起被称为一个 &quot;规则&quot;。</span></span><br><span class="line"><span class="comment">转换规则可分为 &quot;规范化&quot;或 &quot;探索&quot;规则。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If an expression in the tree matches the match pattern, then a new expression</span></span><br><span class="line"><span class="comment">will be constructed according to the replace pattern. Note that &quot;replace&quot; means</span></span><br><span class="line"><span class="comment">the new expression is a logical replacement for the existing expression, not</span></span><br><span class="line"><span class="comment">that the existing expression needs to physically be replaced. Depending on the</span></span><br><span class="line"><span class="comment">context, the existing expression may be discarded, or it may be retained side-</span></span><br><span class="line"><span class="comment">by-side with the new expression in the memo group.</span></span><br><span class="line"><span class="comment">如果树中的一个表达式与匹配模式相匹配，那么一个新的表达式将根据替换模式构建新的表达式。</span></span><br><span class="line"><span class="comment">请注意，&quot;替换&quot;意味着新的表达式是对现有表达式的逻辑替换，而不是说现有的表达式需要被物理替换。</span></span><br><span class="line"><span class="comment">根据上下文，现有的表达式可能会被丢弃，或者它可能会与新表达式一起被保留在memo组中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Normalization rules are cost-agnostic, as they are always considered to be</span></span><br><span class="line"><span class="comment">beneficial. All normalization rules are implemented by the normalizing factory,</span></span><br><span class="line"><span class="comment">which does its best to map all logically equivalent expression trees to a</span></span><br><span class="line"><span class="comment">single canonical form from which searches can branch out. See the Prep section</span></span><br><span class="line"><span class="comment">for more details.</span></span><br><span class="line"><span class="comment">正常化规则是不计成本的，因为它们总是被认为是有益的。所有的规范化规则都由规范化factory实现。</span></span><br><span class="line"><span class="comment">它尽力将所有逻辑上相等的表达式树映射到一个单一的规范化形式，搜索可以从该形式开始分支。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Exploration rules generate equivalent expression trees that must be costed in</span></span><br><span class="line"><span class="comment">order to determine the lowest cost alternative. All exploration rules are</span></span><br><span class="line"><span class="comment">implemented by the explorer, which is optimized to efficiently enumerate all</span></span><br><span class="line"><span class="comment">possible expression tree combinations in the memo in order to look for rule</span></span><br><span class="line"><span class="comment">matches. When it finds a match, the explorer applies the rule and adds an</span></span><br><span class="line"><span class="comment">equivalent expression to the existing memo group. See the Search section for</span></span><br><span class="line"><span class="comment">more details.</span></span><br><span class="line"><span class="comment">探索规则产生等价表达树，必须对其进行成本计算，以确定成本最低的选择</span></span><br><span class="line"><span class="comment">所有的探索规则都由explorer实现。explorer经过优化，可以有效地列举备忘录中所有的可能的表达式树组合，以寻找匹配的规则。</span></span><br><span class="line"><span class="comment">当它找到一个匹配项时，explorer就会应用该规则，并在现有的备忘录组中添加一个等价的表达式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Some examples of transforms:</span></span><br><span class="line"><span class="comment">转换的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Join commutativity</span></span><br><span class="line"><span class="comment">Swaps the order of the inputs to an inner join.</span></span><br><span class="line"><span class="comment">SELECT * FROM a, b =&gt; SELECT * FROM b, a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Join associativity</span></span><br><span class="line"><span class="comment">Reorders the children of a parent and child join</span></span><br><span class="line"><span class="comment">SELECT * FROM (SELECT * FROM a, b), c</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">SELECT * FROM (SELECT * FROM a, c), b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Predicate pushdown</span></span><br><span class="line"><span class="comment">Moves predicates below joins</span></span><br><span class="line"><span class="comment">SELECT * FROM a, b USING (x) WHERE a.x &lt; 10</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">SELECT * FROM (SELECT * FROM a WHERE a.x &lt; 10), b USING (x)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Join elimination</span></span><br><span class="line"><span class="comment">Removes unnecessary joins based on projected columns and foreign keys.</span></span><br><span class="line"><span class="comment">SELECT a.x FROM a, b USING (x)</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">SELECT a.x FROM a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Distinct/group-by elimination</span></span><br><span class="line"><span class="comment">Removes unnecessary distinct/group-by operations based on keys.</span></span><br><span class="line"><span class="comment">SELECT DISTINCT a.x FROM a</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">SELECT a.x FROM a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Predicate inference</span></span><br><span class="line"><span class="comment">Adds predicates based on filter conditions.</span></span><br><span class="line"><span class="comment">SELECT * FROM a, b USING (x)</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">SELECT * FROM a, b USING (x) WHERE a.x IS NOT NULL AND b.x IS NOT NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Decorrelation</span></span><br><span class="line"><span class="comment">Replaces correlated subqueries with semi-join, anti-join and apply ops.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Scan to index scan</span></span><br><span class="line"><span class="comment">Transforms scan operator into one or more index scans on covering indexes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Inner join to merge join</span></span><br><span class="line"><span class="comment">Generates alternate merge-join operator from default inner-join operator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Much of the optimizer&#x27;s rule matching and application code is generated by a</span></span><br><span class="line"><span class="comment">tool called Optgen, short for &quot;optimizer generator&quot;. Optgen is a domain-</span></span><br><span class="line"><span class="comment">specific language (DSL) that provides an intuitive syntax for defining</span></span><br><span class="line"><span class="comment">transform rules. Here is an example:</span></span><br><span class="line"><span class="comment">大部分优化器的规则匹配和应用代码是由一个叫做Optgen的工具生成的，是 &quot;优化器生成器 &quot;的简称。</span></span><br><span class="line"><span class="comment">Optgen是一种特定的语言（DSL），提供了一个直观的语法来定义转换规则。下面是一个例子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[NormalizeEq]</span></span><br><span class="line"><span class="comment">(Eq</span></span><br><span class="line"><span class="comment">$left:^(Variable)</span></span><br><span class="line"><span class="comment">$right:(Variable)</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">=&gt;</span></span><br><span class="line"><span class="comment">(Eq $right $left)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The expression above the arrow is the match pattern and the expression below</span></span><br><span class="line"><span class="comment">the arrow is the replace pattern. This example rule will match Eq expressions</span></span><br><span class="line"><span class="comment">which have a left input which is not a Variable operator and a right input</span></span><br><span class="line"><span class="comment">which is a Variable operator. The replace pattern will trigger a replacement</span></span><br><span class="line"><span class="comment">that reverses the two inputs. In addition, custom match and replace functions</span></span><br><span class="line"><span class="comment">can be defined in order to run arbitrary Go code.</span></span><br><span class="line"><span class="comment">箭头上方的表达式是匹配模式，箭头下方的表达式是替换模式。这个示例规则将匹配Eq表达式，它的左边输入不是变量运算符，右边输入是变量运算符。</span></span><br><span class="line"><span class="comment">替换模式将触发一个替换将两个输入颠倒过来。</span></span><br><span class="line"><span class="comment">此外，可以定义自定义的匹配和替换函数，以运行任意的Go代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Prep</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Prep (short for &quot;prepare&quot;) is the first phase of query optimization, in which</span></span><br><span class="line"><span class="comment">the annotated AST is transformed into a single normalized &quot;expression tree&quot;.</span></span><br><span class="line"><span class="comment">The optimizer directly creates the expression tree in the memo data structure</span></span><br><span class="line"><span class="comment">rather than first constructing an interimg/images_optimizerte data structure. A forest of</span></span><br><span class="line"><span class="comment">equivalent trees will be generated in later phases, but at the end of the prep</span></span><br><span class="line"><span class="comment">phase, the memo contains just one normalized tree that is logically equivalent</span></span><br><span class="line"><span class="comment">to the SQL query.</span></span><br><span class="line"><span class="comment">Prep（&quot;prepare&quot;的简称）是查询优化的第一个阶段，在这个阶段中注释的AST被转化为一个单一的规范化的&quot;表达式树&quot;。</span></span><br><span class="line"><span class="comment">优化器直接在备忘录数据结构中创建表达式树而不是首先构建一个中间数据结构。</span></span><br><span class="line"><span class="comment">一片等价树的森林将在以后的阶段生成，但是在准备阶段结束时，备忘录只包含一个规范化的树，它与SQL查询的逻辑等价。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">During the prep phase, placeholder values are not yet known, so normalization</span></span><br><span class="line"><span class="comment">cannot go as far as it can during later phases. However, this also means that</span></span><br><span class="line"><span class="comment">the resulting expression tree can be cached in response to a PREPARE statement,</span></span><br><span class="line"><span class="comment">and then be reused as a starting point each time an EXECUTE statement provides</span></span><br><span class="line"><span class="comment">new placeholder values.</span></span><br><span class="line"><span class="comment">在准备阶段，占位符值还不知道，所以规范化不能像以后的阶段那样走得更远。</span></span><br><span class="line"><span class="comment">然而，这也意味着产生的表达式树可以在响应PREPARE语句时被缓存起来，然后在每次EXECUTE语句提供新的占位符值时作为起点重新使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The memo expression tree is constructed by the normalizing factory, which does</span></span><br><span class="line"><span class="comment">its best to map all logically equivalent expression trees to a single canonical</span></span><br><span class="line"><span class="comment">form from which searches can branch out. The factory has an interface similar</span></span><br><span class="line"><span class="comment">to this:</span></span><br><span class="line"><span class="comment">备忘录表达式树是由规范化工厂构建的，它尽力将所有逻辑上等价的表达式树映射为单一的规范化表达式。</span></span><br><span class="line"><span class="comment">便搜索可以从该形式分支出来。该工厂有一个类似于</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ConstructConst(value PrivateID) GroupID</span></span><br><span class="line"><span class="comment">ConstructAnd(conditions ListID) GroupID</span></span><br><span class="line"><span class="comment">ConstructInnerJoin(left GroupID, right GroupID, on GroupID) GroupID</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The factory methods construct a memo expression tree bottom-up, with each memo</span></span><br><span class="line"><span class="comment">group becoming an input to operators higher in the tree.</span></span><br><span class="line"><span class="comment">工厂方法自底向上地构建一个备忘录表达式树，每个备忘录组成为树中更高一级运算符的输入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">As each expression is constructed by the factory, it transitively applies</span></span><br><span class="line"><span class="comment">normalization rules defined for that expression type. This may result in the</span></span><br><span class="line"><span class="comment">construction of a different type of expression than what was requested. If,</span></span><br><span class="line"><span class="comment">after normalization, the expression is already part of the memo, then</span></span><br><span class="line"><span class="comment">construction is a no-op. Otherwise, a new memo group is created, with the</span></span><br><span class="line"><span class="comment">normalized expression as its first and only expression.</span></span><br><span class="line"><span class="comment">当工厂构建每个表达式时，它都会顺便应用为该表达式类型定义的规范化规则。</span></span><br><span class="line"><span class="comment">这可能会导致构建的表达式类型与所要求的不同。</span></span><br><span class="line"><span class="comment">如果，规范化后，该表达式已经是备忘录的一部分，那么构造是一个无用功。</span></span><br><span class="line"><span class="comment">否则，就会创建一个新的备忘录组，把规范化后的表达式作为其第一个也是唯一的表达式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">By applying normalization rules as the expression tree is constructed, the</span></span><br><span class="line"><span class="comment">factory can avoid creating interimg/images_optimizerte expressions; often, &quot;replacement&quot; of</span></span><br><span class="line"><span class="comment">an existing expression means it&#x27;s never created to begin with.</span></span><br><span class="line"><span class="comment">通过在构建表达式树时应用规范化规则，工厂可以避免创建中间表达式。</span></span><br><span class="line"><span class="comment">通常，现有表达式的&quot;替换&quot;意味着它从一开始就没有被创建。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">During Prep, all columns used by the SQL query are given a numeric index that</span></span><br><span class="line"><span class="comment">is unique across the query. Column numbering involves assigning every base</span></span><br><span class="line"><span class="comment">column and non-trivial projection in a query a unique, query-specific index.</span></span><br><span class="line"><span class="comment">Giving each column a unique index allows the expression nodes mentioned above</span></span><br><span class="line"><span class="comment">to track input and output columns, or really any set of columns during Prep and</span></span><br><span class="line"><span class="comment">later phases, using a bitmap (FastIntSet). The bitmap representation allows</span></span><br><span class="line"><span class="comment">fast determination of compatibility between expression nodes and is utilized by</span></span><br><span class="line"><span class="comment">transforms to determine the legality of such operations.</span></span><br><span class="line"><span class="comment">在准备过程中，SQL查询所使用的所有列都被赋予一个数字索引，该索引在整个查询中是唯一的。</span></span><br><span class="line"><span class="comment">列的编号涉及到为每一个基列和非微不足道的投影分配一个唯一的、针对查询的索引。</span></span><br><span class="line"><span class="comment">给予每一个列一个唯一的索引，允许上面提到的表达式结点追踪输入和输出列，或者在准备阶段和后期阶段</span></span><br><span class="line"><span class="comment">追踪任何一组列，使用位图（FastIntSet）。位图表示法允许快速确定表达式节点之间的兼容性，</span></span><br><span class="line"><span class="comment">并通过转换来确定这种操作的合法性而被利用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The Prep phase also computes logical properties, such as the input and output</span></span><br><span class="line"><span class="comment">columns of each (sub-)expression, equivalent columns, not-null columns and</span></span><br><span class="line"><span class="comment">functional dependencies. These properties are computed bottom-up as part of</span></span><br><span class="line"><span class="comment">constructing the expression tree.</span></span><br><span class="line"><span class="comment">预备阶段还计算逻辑属性，例如每一个（子）表达式的输入和输出列、等价列、非空列和 功能依赖性。</span></span><br><span class="line"><span class="comment">这些属性是自底向上计算的，是构建表达式树的一部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Rewrite</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Rewrite is the second phase of query optimization. Placeholder values are</span></span><br><span class="line"><span class="comment">available starting at this phase, so new normalization rules will typically</span></span><br><span class="line"><span class="comment">match once constant values are substituted for placeholders. As mentioned in</span></span><br><span class="line"><span class="comment">the previous section, the expression tree produced by the Prep phase can be</span></span><br><span class="line"><span class="comment">cached and serve as the starting point for the Rewrite phase. In addition, the</span></span><br><span class="line"><span class="comment">Rewrite phase takes a set of physical properties that are required from the</span></span><br><span class="line"><span class="comment">result, such as row ordering and column naming.</span></span><br><span class="line"><span class="comment">重写是查询优化器的第二个阶段。占位符的值从这个阶段开始可以使用，所以一旦常量值被替换为占位符，新的规范化规则通常会匹配。</span></span><br><span class="line"><span class="comment">正如在上一节中提到的那样，在预处理阶段生成的表达式树能够被缓存然后作为重写阶段的起点。</span></span><br><span class="line"><span class="comment">此外，重写阶段从结果中获取一组所需的物理属性，例如 行的排列顺序以及列名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The Rewrite and Search phases have significant overlap. Both phases perform</span></span><br><span class="line"><span class="comment">transformations on the expression tree. However, Search preserves the matched</span></span><br><span class="line"><span class="comment">expression side-by-side with the new expression, while Rewrite simply discards</span></span><br><span class="line"><span class="comment">the matched expression, since the new expression is assumed to always be</span></span><br><span class="line"><span class="comment">better. In addition, the application of exploration rules may trigger</span></span><br><span class="line"><span class="comment">additional normalization rules, which may in turn trigger additional</span></span><br><span class="line"><span class="comment">exploration rules.</span></span><br><span class="line"><span class="comment">重写阶段和搜索阶段具有很大的重叠，两个阶段都在表达式树是那个做了转换。</span></span><br><span class="line"><span class="comment">然而，搜索阶段保留了与新表达式并列的匹配表达式，，而重写阶段简单的丢弃了匹配表达式，因为新表达式总是被认为是更好的。</span></span><br><span class="line"><span class="comment">此外，探索规则的应用，可能触发额外的规范化规则，而这些规则反过来触发额外的探索表达式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Together, the Rewrite and Search phases are responsible for finding the</span></span><br><span class="line"><span class="comment">expression that can provide the required set of physical properties at the</span></span><br><span class="line"><span class="comment">lowest possible execution cost. That mandate is recursively applied; in other</span></span><br><span class="line"><span class="comment">words, each subtree is also optimized with respect to a set of physical</span></span><br><span class="line"><span class="comment">properties required by its parent, and the goal is to find the lowest cost</span></span><br><span class="line"><span class="comment">equivalent expression. An example of an &quot;interior&quot; optimization goal is a merge</span></span><br><span class="line"><span class="comment">join that requires its inner child to return its rows in a specific order. The</span></span><br><span class="line"><span class="comment">same group can be (and sometimes is) optimized multiple times, but with</span></span><br><span class="line"><span class="comment">different required properties each time.</span></span><br><span class="line"><span class="comment">重写阶段和搜索阶段一起负责找到那个表达式，该表达式能够以尽可能低的执行成本提供所需的物理属性集。</span></span><br><span class="line"><span class="comment">这一任务是递归应用的；换句话说，每个子树也是针对其父级所要求的一组物理属性进行优化的，目标是找到成本最低的等价表达。</span></span><br><span class="line"><span class="comment">一个&quot;内部&quot;优化目标的例子是一个合并的连接，它要求其内部的子节点以特定的顺序返回其行。</span></span><br><span class="line"><span class="comment">同一个组可以（有时也会）被多次优化，但是每次所要求的属性都不同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Search</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Search is the final phase of optimization. Search begins with a single</span></span><br><span class="line"><span class="comment">normalized tree that was created by the earlier phases. For each group, the</span></span><br><span class="line"><span class="comment">&quot;explorer&quot; component generates alternative expressions that are logically</span></span><br><span class="line"><span class="comment">equivalent to the normalized expression, but which may have very different</span></span><br><span class="line"><span class="comment">execution plans. The &quot;coster&quot; component computes the estimated cost for each</span></span><br><span class="line"><span class="comment">alternate expression. The optimizer remembers the &quot;best expression&quot; for each</span></span><br><span class="line"><span class="comment">group, for each set of physical properties required of that group.</span></span><br><span class="line"><span class="comment">搜索阶段是优化器的最后一个阶段。搜索以一个单独的在之前的阶段中创建的规范化过的树开始。</span></span><br><span class="line"><span class="comment">对于每个组，&quot;探索器&quot;组件生成可选的表达式，这些表达式在逻辑上与规范化的表达式等价的，但是可能有非常不同的执行计划。</span></span><br><span class="line"><span class="comment">&quot;成本计算器&quot;组件为每个可选的表达式计算预估代价。</span></span><br><span class="line"><span class="comment">优化器为每个组，为那个组需要的每组物理属性，记住这些&quot;最佳表达式&quot;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Optimization of a group proceeds in two phases:</span></span><br><span class="line"><span class="comment">一个组的优化过程分两个阶段进行：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Compute the cost of any previously generated expressions. That set initially</span></span><br><span class="line"><span class="comment">contains only the group&#x27;s normalized expression, but exploration may yield</span></span><br><span class="line"><span class="comment">additional expressions. Costing a parent expression requires that the children</span></span><br><span class="line"><span class="comment">first be costed, so costing triggers a recursive traversal of the memo groups.</span></span><br><span class="line"><span class="comment">1. 计算任何先前生成的表达式的成本。这个集合最初只包含该组的规范化过的表达式，但探索可能会产生额外的表达式。</span></span><br><span class="line"><span class="comment">计算父表达式的成本需要首先计算子表达式的成本，所以计算成本会触发对memo groups的递归遍历。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. Invoke the explorer to generate new equivalent expressions for the group.</span></span><br><span class="line"><span class="comment">Those new expressions are costed once the optimizer loops back to the first</span></span><br><span class="line"><span class="comment">phase.</span></span><br><span class="line"><span class="comment">2. 调用探索器去为该组生成新的等价表达式</span></span><br><span class="line"><span class="comment">一旦优化器循环到第一阶段，这些新的表达式就会被计算成本。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In order to avoid a combinatorial explosion in the number of expression trees,</span></span><br><span class="line"><span class="comment">the optimizer utilizes the memo structure. Due to the large number of possible</span></span><br><span class="line"><span class="comment">plans for some queries, the optimizer cannot always explore all of them.</span></span><br><span class="line"><span class="comment">Therefore, it proceeds in multiple iterative &quot;passes&quot;, until either it hits</span></span><br><span class="line"><span class="comment">some configured time or resource limit, or until an exhaustive search is</span></span><br><span class="line"><span class="comment">complete. As long as the search is allowed to complete, the best plan will be</span></span><br><span class="line"><span class="comment">found, just as in Volcano and Cascades.</span></span><br><span class="line"><span class="comment">为避免在大量表达式树中的组合探索，优化器利用了memo结构。由于某些查询有大量的可能的计划，优化器不能总是探索全部计划。</span></span><br><span class="line"><span class="comment">因此，它通过多次迭代&quot;通过&quot;的方式探索全部计划，直到遇到一些配置时间或者资源限制，直到详尽的搜索完成。</span></span><br><span class="line"><span class="comment">只要允许搜索完成，最佳计划就会被找到。就像在Volcano和Cascades中一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The optimizer uses several techniques to maximize the chance that it finds the</span></span><br><span class="line"><span class="comment">best plan early on:</span></span><br><span class="line"><span class="comment">优化器用了几种技术去最大限度地提高尽早找到最优计划的机会：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- As with Cascades, the search is highly directed, interleaving exploration</span></span><br><span class="line"><span class="comment">with costing in order to prune parts of the tree that cannot yield a better</span></span><br><span class="line"><span class="comment">plan. This contrasts with Volcano, which first generates all possible plans in</span></span><br><span class="line"><span class="comment">one global phase (exploration), and then determines the lowest cost plan in</span></span><br><span class="line"><span class="comment">another global phase (costing).</span></span><br><span class="line"><span class="comment">- 像cascades，搜索是高度定向的，将探索成本和计算成本交织在一起，以修建树上不能生成更优计划的部分。</span></span><br><span class="line"><span class="comment">这与Volcano形成鲜明对比，它首先在全局阶段（exploration）生成所有可行的计划，然后在另一个全局阶段（costing）决定代价最低的计划。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- The optimizer uses a simple hill climbing heuristic to make greedy progress</span></span><br><span class="line"><span class="comment">towards the best plan. During a given pass, the optimizer visits each group and</span></span><br><span class="line"><span class="comment">performs costing and exploration for that group. As long as doing that yields a</span></span><br><span class="line"><span class="comment">lower cost expression for the group, the optimizer will repeat those steps.</span></span><br><span class="line"><span class="comment">This finds a local maxima for each group during the current pass.</span></span><br><span class="line"><span class="comment">- 优化器使用一个简单的爬坡启发式（hill climbing heuristic）来进行贪婪的进展朝着最佳计划的方向前进。</span></span><br><span class="line"><span class="comment">在一个给定的传递期间中，优化器访问每个组并对该组进行成本计算和探索。</span></span><br><span class="line"><span class="comment">只要这样做能产生一个的较低成本表达，优化器就会重复这些步骤。</span></span><br><span class="line"><span class="comment">这样就可以在当前的过程中为每个组找到一个局部最大值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In order to avoid costing or exploring parts of the search space that cannot</span></span><br><span class="line"><span class="comment">yield a better plan, the optimizer performs aggressive &quot;branch and bound</span></span><br><span class="line"><span class="comment">pruning&quot;. Each group expression is optimized with respect to a &quot;budget&quot;</span></span><br><span class="line"><span class="comment">parameter. As soon as this budget is exceeded, optimization of that expression</span></span><br><span class="line"><span class="comment">terminates. It&#x27;s not uncommon for large sections of the search space to never</span></span><br><span class="line"><span class="comment">be costed or explored due to this pruning. Example:</span></span><br><span class="line"><span class="comment">为了避免成本计算或探索 无法产生更好计划的搜索空间的部分，优化器执行激进的&quot;分支和绑定修剪&quot;。</span></span><br><span class="line"><span class="comment">每个组表达式都针对&quot;预算&quot;参数进行了优化，一旦超出此预算，该表达式的优化就会终止。</span></span><br><span class="line"><span class="comment">由于这种修剪，搜索空间的大部分从未被计算成本或探索的情况并不少见。例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">innerJoin</span></span><br><span class="line"><span class="comment">left:  cost = 50</span></span><br><span class="line"><span class="comment">right: cost = 75</span></span><br><span class="line"><span class="comment">on:    cost = 25</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If the current best expression for the group has a cost of 100, then the</span></span><br><span class="line"><span class="comment">optimizer does not need to cost or explore the &quot;on&quot; child of the join, and</span></span><br><span class="line"><span class="comment">does not need to cost the join itself. This is because the combined cost of</span></span><br><span class="line"><span class="comment">the left and right children already exceeds 100.</span></span><br><span class="line"><span class="comment">如果该组的当前最佳表达式的成本是100，那么优化器就不需要对join的&quot;on&quot;算子进行成本计算或探索，也不需要对join本身进行计算。</span></span><br><span class="line"><span class="comment">这是因为左翼和右翼子节点的总成本已经超过了100。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>优化器</tag>
      </tags>
  </entry>
  <entry>
    <title>yacc以及crdb中的应用</title>
    <url>/2021/02/07/yacc%E4%BB%A5%E5%8F%8Acrdb%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、yacc工作原理"><a href="#一、yacc工作原理" class="headerlink" title="一、yacc工作原理"></a>一、yacc工作原理</h2><ul>
<li>lex 对.l文件进行词法解析，识别token</li>
<li>yacc 对.y文件进行语法解析，匹配规则</li>
<li>生成语法树<br><img src="/img/images_yacc/generateProgress.png"></li>
</ul>
<h2 id="二、解释器生成流程"><a href="#二、解释器生成流程" class="headerlink" title="二、解释器生成流程"></a>二、解释器生成流程</h2><ul>
<li>example.l 定义处理 token</li>
<li>example.y 定义匹配 语法规则</li>
<li>yacc 生成 y.tab.h 和 y.tab.c (yyparse)</li>
<li>lex 根据 example.l 和 y.tab.h 生成 yylex </li>
<li>compile 生成解释器<br><img src="/img/images_yacc/buildCompiler.png"></li>
</ul>
<h2 id="三、yacc文件格式"><a href="#三、yacc文件格式" class="headerlink" title="三、yacc文件格式"></a>三、yacc文件格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">第一部分：定义段</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line"> 第二部分：规则段</span><br><span class="line">%%</span><br><span class="line"> 第三部分：辅助函数</span><br><span class="line"> 在yacc中辅助函数可以放到第一部分内</span><br></pre></td></tr></table></figure>

<h3 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一部分主要包含的一些定义和声明：文件包含，宏定义，数据类型定义，全局变量定义，函数声明等。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则段（规则-操作）"><a href="#规则段（规则-操作）" class="headerlink" title="规则段（规则+操作）"></a>规则段（规则+操作）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第二部分主要是对文法的终结符和非终结符做一些相关声明。</span><br><span class="line">(1) 声明主要有：%token，%left，%right，%nonassoc，%union，%type，%start</span><br><span class="line"></span><br><span class="line">1、类型联合 </span><br><span class="line">   %union               </span><br><span class="line">   //一般用来定义yacc文件中token所使用的数据类型</span><br><span class="line"></span><br><span class="line">2、终结符与非终结符</span><br><span class="line">   %token &lt;dataType&gt;    //终结符</span><br><span class="line">   %type  &lt;dataType&gt;    //非终结符</span><br><span class="line">   //上述dataType 可以是union中定义的类型，或者头文件中引入的包中的类型</span><br><span class="line">   //终结符与非终结符可以由字母，数字，下划线组成，但必须用字母开头</span><br><span class="line"></span><br><span class="line">3、语法开始符</span><br><span class="line">   %start </span><br><span class="line">   //默认情况，yacc自动将语法规则部分中第一条语法规则左部的非终结符作为语法开始符。</span><br><span class="line"></span><br><span class="line">4、结合性与优先级</span><br><span class="line">   %left       左结合    例：%left &#x27;+&#x27; &#x27;-&#x27;      </span><br><span class="line">                            1+2+3     ==&gt;     (1+2)+3</span><br><span class="line">                            1+2-3     ==&gt;     (1+2)-3</span><br><span class="line">   %right      右结合    例：%right &#x27;+&#x27;      </span><br><span class="line">                            1+2+3     ==&gt;     1+(2+3)</span><br><span class="line">   %nonassoc   不结合    例：%nonassoc &#x27;&lt;&#x27; &#x27;&gt;&#x27;</span><br><span class="line">                            a&lt;b&lt;c     ==&gt;     不允许连用</span><br><span class="line">                            a&lt;b&gt;c     ==&gt;     不允许连用</span><br><span class="line">   // 对于 %left %right %nonassoc</span><br><span class="line">   // 排在前面行的算符比后面行的算符的优先级低；排在同一行的算符优先级相同。</span><br><span class="line">   // 同一优先级的算符，处理结合性或者非结合性时，可以替换考虑</span><br><span class="line">   // 例： 1+2-3      ==&gt;     (1+2)-3</span><br><span class="line">   // 例： a&lt;b&gt;c      ==&gt;     yyerror(),不允许连用</span><br><span class="line"></span><br><span class="line">   %prec       %prec前面的规则优先级与%prec后面的规则相同</span><br><span class="line"></span><br><span class="line">(2) 规则段定义了文法的非终结符及产生式集合，以及当归约整个产生式时应执行的操作。</span><br><span class="line">    通过BNF定义规则。每一条规则中语法符号都有一个语义值。   </span><br><span class="line">    目标符号（冒号左边的语法符号）用$$代替。</span><br><span class="line">    右边语法符号的语义值以此用$1 $2代替,代表第几个参数。</span><br><span class="line">    stmt： </span><br><span class="line">      expr1 expr2</span><br><span class="line">      &#123; </span><br><span class="line">          //yacc中为c的代码。</span><br><span class="line">          //goyacc中为go代码，表示匹配到这条规则时，所需执行的操作</span><br><span class="line">          //func1 可以是引入的包中的操作，也可以是在此.y文件中自定义的</span><br><span class="line">          $$ = func1($1,$2)</span><br><span class="line">      &#125;</span><br><span class="line">      | expr1 expr2 expr3</span><br><span class="line">      &#123;</span><br><span class="line">          $$ = func2($1,$2,$3)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数段"><a href="#辅助函数段" class="headerlink" title="辅助函数段"></a>辅助函数段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包括规则段用到的函数，以及 yylex()，yyerror()，main()，yywrap() 。</span><br><span class="line">1、yylex()</span><br><span class="line">一般是由lex文件生成的，在yyparse()中调用，也可以自定义。</span><br><span class="line">2、yyerror()</span><br><span class="line">在yyparse()中被调用，出现错误时使用</span><br><span class="line">3、yywrap()</span><br><span class="line">在yyparse()中被调用，表示目前文件扫描结束后，下一步的动作</span><br><span class="line">4、yyparse() </span><br><span class="line">由yaccpar根据sql.y文件中定义的规则生成的，c的规则匹配代码</span><br></pre></td></tr></table></figure>

<h2 id="四、lex词法解析"><a href="#四、lex词法解析" class="headerlink" title="四、lex词法解析"></a>四、lex词法解析</h2><p><img src="/img/images_yacc/rule.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">[0-9]*   0或多个数字    </span><br><span class="line">[abc]*   0或多个a/b/c,如 aa,abb,c,ca,为空也可</span><br><span class="line">[abc]+   1或多个a/b/c，如 aa,abb,c,ca</span><br><span class="line">.?       0或1个 . </span><br></pre></td></tr></table></figure>

<h2 id="五、移进规约"><a href="#五、移进规约" class="headerlink" title="五、移进规约"></a>五、移进规约</h2><h3 id="bison采用自底向上的分析方法LALR-1"><a href="#bison采用自底向上的分析方法LALR-1" class="headerlink" title="bison采用自底向上的分析方法LALR(1)"></a>bison采用自底向上的分析方法LALR(1)</h3><pre><code>自底向上算法要做的事情是，对于一个接一个读入的 token，何时移进，何时归约。LR(1) 中的 1表示，只需预读 1个语素，就可以确定是移进，还是归约。
</code></pre>
<h3 id="关键动作"><a href="#关键动作" class="headerlink" title="关键动作"></a>关键动作</h3><ul>
<li>移进(shift)<br>  读取的 token 移进到分析栈中。</li>
<li>规约(reduce)<br>  当分析栈顶的 n 个符号匹配某规则的右端时，用该规则的左端取代之。<br>  如：当规则为<br>      vardef:  INT ids ‘;’ { 处理 };<br>      若分析栈此时为 INT ids 时，当下一个读入的语素为 ‘;’ 时，分析栈为INT ids ‘;’ 此时跟上面的规则符合，所以可以左端取代右端，即用 栈内vardef 取代 INT ids ‘;’</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 规则</span><br><span class="line">expr: NUMBER &#123;$$ = $1;&#125;</span><br><span class="line">| expr &#x27;+&#x27; expr  &#123;$$ = $1 + $3;&#125;</span><br><span class="line">| expr &#x27;-&#x27; expr  &#123;$$ = $1 - $3;&#125;</span><br><span class="line">| &#x27;(&#x27; expr &#x27;)&#x27;   &#123;$$ = $2;&#125;</span><br><span class="line"></span><br><span class="line">- 示例1</span><br><span class="line">分析语句：3 + 5 + 8</span><br><span class="line">词素    语素       动作    分析栈</span><br><span class="line">3       NUMBER    移进    NUMBER</span><br><span class="line">//此时 向后看一个元素，无法规约，但是可以移进</span><br><span class="line">                  规约    expr</span><br><span class="line">+       &#x27;+&#x27;       移进    expr &#x27;+&#x27;</span><br><span class="line">5       NUMBER    移进    expr &#x27;+&#x27; NUMBER   </span><br><span class="line">                  规约    expr &#x27;+&#x27; expr</span><br><span class="line"></span><br><span class="line">//expr ： expr &#x27;+&#x27; expr  &#123;$$ = $1 + $3;&#125; </span><br><span class="line">//此时符合规则，可规约  </span><br><span class="line">//下一语素 &#x27;+&#x27; 符合匹配规则，也可移进</span><br><span class="line">//产生移进规约冲突</span><br><span class="line"></span><br><span class="line">- 示例2</span><br><span class="line">分析语句：3 + ( 5 + 8 )</span><br><span class="line">词素    语素       动作    分析栈</span><br><span class="line">3       NUMBER    移进    NUMBER</span><br><span class="line">                  规约    expr</span><br><span class="line">+       &#x27;+&#x27;       移进    expr &#x27;+&#x27;</span><br><span class="line">(       &#x27;(&#x27;       移进    expr &#x27;+&#x27; &#x27;(&#x27;</span><br><span class="line">5       NUMBER    移进    expr &#x27;+&#x27; &#x27;(&#x27; NUMBER   </span><br><span class="line">                  规约    expr &#x27;+&#x27; &#x27;(&#x27; expr</span><br><span class="line">+       &#x27;+&#x27;       移进    expr &#x27;+&#x27; &#x27;(&#x27; expr &#x27;+&#x27;</span><br><span class="line">8       NUMBER    移进    expr &#x27;+&#x27; &#x27;(&#x27; expr &#x27;+&#x27; NUMBER</span><br><span class="line">                  规约    expr &#x27;+&#x27; &#x27;(&#x27; expr &#x27;+&#x27; expr</span><br><span class="line">                  规约    expr &#x27;+&#x27; &#x27;(&#x27; expr </span><br><span class="line">)       &#x27;)&#x27;       移进    expr &#x27;+&#x27; &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">                  规约    expr &#x27;+&#x27; expr</span><br><span class="line">                  规约    expr</span><br></pre></td></tr></table></figure>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>冲突是指移进规约过程中可生成的语法树不止一个，文法具有二义性</p>
<ul>
<li>移进&#x2F;归约冲突(shift&#x2F;reduce conflicts)<br>  在某一时刻，可以移进，也可以归约。是选择移进，还是归约？这就是移进&#x2F;归约冲突。这种冲突可以接受。yacc优先移进。</li>
<li>归约&#x2F;归约冲突 (Reduce&#x2F;Reduce Conflicts)<br>  当分析栈顶的符号序列可归约到多于一个规则时，选择哪一个规则？这就是归约&#x2F;归约冲突。</li>
</ul>
<h2 id="六、简单例子–计算器"><a href="#六、简单例子–计算器" class="headerlink" title="六、简单例子–计算器"></a>六、简单例子–计算器</h2><ul>
<li><p>example.y</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">// 在lex.yy.c里由lex生成的生成的词法分析函数，会被yyparse()调用。</span><br><span class="line">extern int yylex(void); </span><br><span class="line">extern int yyparse(void); </span><br><span class="line">void yyerror(char * s) </span><br><span class="line">&#123;    </span><br><span class="line">    fprintf (stderr, &quot;%s\n&quot;, s); </span><br><span class="line">&#125;  </span><br><span class="line">int yywrap()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return yyparse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%union</span><br><span class="line">&#123;</span><br><span class="line">  char *string;</span><br><span class="line">  double number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;number&gt; NUMBER</span><br><span class="line">%token &lt;string&gt; WORD</span><br><span class="line"></span><br><span class="line">%type &lt;number&gt; expr;</span><br><span class="line">/*</span><br><span class="line"> %left 表示左结合，%right 表示右结合。后列出的定义拥有更高的优先权</span><br><span class="line">*/</span><br><span class="line">%left  &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left  &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">program:</span><br><span class="line">| program statement &#x27;\n&#x27;</span><br><span class="line">;</span><br><span class="line">statement: expr &#123; printf(&quot;结果为：%lf\n&quot;,$1); &#125;</span><br><span class="line">;</span><br><span class="line">expr: NUMBER &#123;$$ = $1;&#125;</span><br><span class="line">| expr &#x27;+&#x27; expr  &#123;$$ = $1 + $3;&#125;</span><br><span class="line">| expr &#x27;-&#x27; expr  &#123;$$ = $1 - $3;&#125;</span><br><span class="line">| expr &#x27;*&#x27; expr  &#123;$$ = $1 * $3;&#125;</span><br><span class="line">| expr &#x27;/&#x27; expr  &#123;</span><br><span class="line">    if($3 == 0.0)</span><br><span class="line">        yyerror(&quot;divide by zero&quot;);</span><br><span class="line">    else </span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">&#125;</span><br><span class="line">| &#x27;(&#x27; expr &#x27;)&#x27;  &#123;$$ =$2;&#125;</span><br><span class="line">| &#x27;-&#x27; expr %prec &#x27;*&#x27; &#123;$$ = -1 * $2;&#125;</span><br><span class="line">;</span><br><span class="line">%%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>example.l</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot; </span><br><span class="line">//包含example.y中定义的终结符常量定义，属性值栈的类型定义，变量yyval外部引用定义</span><br><span class="line">%&#125; </span><br><span class="line">%%</span><br><span class="line"> </span><br><span class="line"> /*整数或者小数 */</span><br><span class="line">\.?[0-9]+|[0-9]+\.[0-9]* &#123; yylval.number = atof(yytext); return NUMBER; &#125; </span><br><span class="line"> /*字符串*/</span><br><span class="line">[a-zA-Z][a-zA-Z0-9]* &#123; yylval.string = strdup(yytext); return WORD;&#125;</span><br><span class="line"></span><br><span class="line">[\n]  &#123; return *yytext;&#125;</span><br><span class="line">[-+()=/\*^]	&#123; return *yytext;&#125;</span><br><span class="line">[ \t]+ ; /* ignore whitespace */  </span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>Makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">counter: example.l example.y</span></span><br><span class="line">	lex example.l</span><br><span class="line">	yacc -d -v example.y</span><br><span class="line">	cc -o <span class="variable">$@</span> lex.yy.c y.tab.c</span><br><span class="line"><span class="section">clean:	</span></span><br><span class="line">	rm counter lex.yy.c y.tab.c y.tab.h y.output	</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、yacc命令"><a href="#七、yacc命令" class="headerlink" title="七、yacc命令"></a>七、yacc命令</h2><p><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/yacc.html">yacc官方用户手册</a></p>
<h3 id="用法概要"><a href="#用法概要" class="headerlink" title="用法概要"></a>用法概要</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yacc [-dltVv] [-b file_prefix] [-Q [y | n]] [-P parser] [-p sym_prefix] file</span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、yacc 命令可将上下文无关的语法转换为一组表，以便简单自动地执行 LALR(1) 解析算法。语法可以不明确。可以使用指定的优先级规则消除不明确性。</span><br><span class="line">2、输出文件 y.tab.c 必须由 C 编译器编译才能生成函数 yyparse()。该程序必须以词法分析器程序 yylex() 以及 main() 和错误处理例程 yyerror() 装入。这些例程必须由用户提供。lex(1) 命令对于创建可供 yacc 使用的词法分析器非常有用。</span><br></pre></td></tr></table></figure>

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y.output     生成的解析器的状态转换</span><br><span class="line">y.tab.c      生成的解析器的源代码</span><br><span class="line">y.tab.h      生成的解析器的头文件</span><br><span class="line">yacc.acts    临时文件</span><br><span class="line">yacc.debug   临时文件</span><br><span class="line">yacc.tmp     临时文件</span><br><span class="line">yaccpar      C 程序的解析器原型</span><br></pre></td></tr></table></figure>
<h3 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">归约-归约冲突和移位-归约冲突的数目在标准错误输出中报告。更详细的报告可以在 y.output 文件中找到。同样，如果某些规则无法从起始符号访问，也会报告该实例。</span><br></pre></td></tr></table></figure>

<h2 id="八、goyacc"><a href="#八、goyacc" class="headerlink" title="八、goyacc"></a>八、goyacc</h2><p>goyacc 是 golang 版的 Yacc。和 Yacc 的功能一样，goyacc 根据输入的语法规则文件，生成该语法规则的 go 语言版解析器。goyacc 生成的解析器 yyParse 要求词法分析器符合下面的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type yyLexer interface &#123;</span><br><span class="line">    Lex(lval *yySymType) int</span><br><span class="line">    Error(e string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type yyLexerEx interface &#123;</span><br><span class="line">    yyLexer</span><br><span class="line">    // Hook for recording a reduction.</span><br><span class="line">    Reduced(rule, state int, lval *yySymType) (stop bool) // Client should copy *lval.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lex应该返回token类型，并将token值放到放在lval中（与yacc的yylval对应）。Error相当于原yacc中的yyerror。</p>
<p><a href="https://github.com/golang/tools/blob/master/cmd/goyacc/testdata/expr/expr.y">goyacc官方示例</a></p>
<h2 id="九、cockroach中的goyacc"><a href="#九、cockroach中的goyacc" class="headerlink" title="九、cockroach中的goyacc"></a>九、cockroach中的goyacc</h2><h3 id="parse解析时序图"><a href="#parse解析时序图" class="headerlink" title="parse解析时序图"></a>parse解析时序图</h3><p><img src="/img/images_yacc/parse.png"></p>
<h3 id="sql-y生成文件-sql-go"><a href="#sql-y生成文件-sql-go" class="headerlink" title="sql.y生成文件 sql.go"></a>sql.y生成文件 sql.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goyacc生成的</span><br><span class="line"><span class="keyword">type</span> sqlLexer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lex(lval *sqlSymType) <span class="type">int</span></span><br><span class="line">	Error(s <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sqlParser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Parse(sqlLexer) <span class="type">int</span></span><br><span class="line">	Lookahead() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sqlParserImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	lval  sqlSymType</span><br><span class="line">	stack [sqlInitialStackSize]sqlSymType</span><br><span class="line">	char  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lval作用：存放token</span><br><span class="line"><span class="keyword">type</span> sqlSymType <span class="keyword">struct</span> &#123;</span><br><span class="line">	yys   <span class="type">int</span></span><br><span class="line">	id    <span class="type">int32</span>         <span class="comment">//token的id，根据sql.y中token的定义顺序，编译生成</span></span><br><span class="line">	pos   <span class="type">int32</span>         <span class="comment">//token开始坐标</span></span><br><span class="line">	str   <span class="type">string</span>        <span class="comment">//token的内容</span></span><br><span class="line">	union sqlSymUnion</span><br><span class="line">&#125;</span><br><span class="line">stack作用：存放state and value，即匹配规则<span class="keyword">type</span>与对应操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="十、生成bnf文件（EBNF范式）"><a href="#十、生成bnf文件（EBNF范式）" class="headerlink" title="十、生成bnf文件（EBNF范式）"></a>十、生成bnf文件（EBNF范式）</h2><h3 id="文件所在位置-pkg-x2F-cmd-x2F-docgen-x2F-exreact-x2F-extract-go"><a href="#文件所在位置-pkg-x2F-cmd-x2F-docgen-x2F-exreact-x2F-extract-go" class="headerlink" title="文件所在位置 pkg&#x2F;cmd&#x2F;docgen&#x2F;exreact&#x2F;extract.go"></a>文件所在位置 pkg&#x2F;cmd&#x2F;docgen&#x2F;exreact&#x2F;extract.go</h3>]]></content>
      <categories>
        <category>cockroachDB</category>
      </categories>
      <tags>
        <tag>解析器</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo博客，设置主题</title>
    <url>/2023/02/17/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境搭建以及主题的设置"><a href="#环境搭建以及主题的设置" class="headerlink" title="环境搭建以及主题的设置"></a>环境搭建以及主题的设置</h2><h3 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h3><h4 id="环境搭建步骤"><a href="#环境搭建步骤" class="headerlink" title="环境搭建步骤"></a>环境搭建步骤</h4><p>1、安装Git,Node.js,Hexo<br>2、GitHub创建个人仓库<br>3、将hexo部署到github<br>4、本地开启server查看效果<br>5、deploy到github发布文章</p>
<h4 id="主题设置步骤"><a href="#主题设置步骤" class="headerlink" title="主题设置步骤"></a>主题设置步骤</h4><p>1、修改blogs&#x2F;_config.yml 文件。设置主题、主题风格以及title等。<br>2、进入主题修改头像、侧边栏、页面显示等。</p>
<h3 id="二、Hexo搭建"><a href="#二、Hexo搭建" class="headerlink" title="二、Hexo搭建"></a>二、Hexo搭建</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="安装Git，Node-js，Hexo"><a href="#安装Git，Node-js，Hexo" class="headerlink" title="安装Git，Node.js，Hexo"></a>安装Git，Node.js，Hexo</h5><p><a href="https://zhuanlan.zhihu.com/p/44213627">一个知乎步骤</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install -- 这一步我没有用，不知道作用</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹目录下有：</p>
<p>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>** _config.yml: 博客的配置文件**</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br><span class="line">hexo deploy -- 可以选择性进行</span><br></pre></td></tr></table></figure>

<h5 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h5><p>假设你的github名字为 zhangsan<br>仓库名字 zhansan.github.io<br>博客访问网址 <a href="https://zhansan.github.io/">https://zhansan.github.io</a></p>
<h5 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h5><h6 id="为自己的电脑生成密钥"><a href="#为自己的电脑生成密钥" class="headerlink" title="为自己的电脑生成密钥"></a>为自己的电脑生成密钥</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>
<p>id_rsa是电脑的私人秘钥，id_rsa.pub是公共秘钥。连接github时，会根据github上的公钥匹配你本地的私钥。当顺利匹配，才能使用git进行本地和github之间文件的传输。</p>
<h6 id="github上添加本地生成的密钥"><a href="#github上添加本地生成的密钥" class="headerlink" title="github上添加本地生成的密钥"></a>github上添加本地生成的密钥</h6><p>在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key 把id_rsa.pub里面的信息复制进去。</p>
<h6 id="在gitbash中，查看是否成功"><a href="#在gitbash中，查看是否成功" class="headerlink" title="在gitbash中，查看是否成功"></a>在gitbash中，查看是否成功</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h5 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h5><h6 id="将hexo生成的文章部署到GitHub上，打开-config-yml修改配置"><a href="#将hexo生成的文章部署到GitHub上，打开-config-yml修改配置" class="headerlink" title="将hexo生成的文章部署到GitHub上，打开_config.yml修改配置"></a>将hexo生成的文章部署到GitHub上，打开_config.yml修改配置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git项目ssh方式的地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h6 id="开始就本地文件生成静态文件，然后部署到github"><a href="#开始就本地文件生成静态文件，然后部署到github" class="headerlink" title="开始就本地文件生成静态文件，然后部署到github"></a>开始就本地文件生成静态文件，然后部署到github</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h3 id="三、必须主题设置"><a href="#三、必须主题设置" class="headerlink" title="三、必须主题设置"></a>三、必须主题设置</h3><h4 id="修改blogs-x2F-config-yml-文件"><a href="#修改blogs-x2F-config-yml-文件" class="headerlink" title="修改blogs&#x2F;_config.yml 文件"></a>修改blogs&#x2F;_config.yml 文件</h4><ul>
<li>1、修改主题，使用next</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment">#theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、主题风格，使用默认即可</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span>  <span class="string">//默认主题</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h4 id="修改blogs-x2F-themes-x2F-next-x2F-config-yml"><a href="#修改blogs-x2F-themes-x2F-next-x2F-config-yml" class="headerlink" title="修改blogs&#x2F;themes&#x2F;next&#x2F;_config.yml"></a>修改blogs&#x2F;themes&#x2F;next&#x2F;_config.yml</h4><ul>
<li>1、更改头像</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片放置在 source/images/头像.png</span></span><br><span class="line"><span class="attr">avatar:</span> </span><br><span class="line">    <span class="attr">url:</span> <span class="string">/images/头像.png</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、设置Menu</li>
</ul>
<p>默认的只有首页和归档两个,menu配置项中上下的顺序决定了menu显示的顺序。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3、创建tags</li>
</ul>
<p>当选择添加tags之后，还需要创建相应的文件blogs&#x2F;tags，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后编辑创建的blogs&#x2F;tags&#x2F;index.md文件，内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">All</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-20 18:57:48</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4、创建abouts、categories</li>
</ul>
<p>操作同上<br>使用时，在每篇文章开头添加，可添加多个，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> Android</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Android</span><br><span class="line"><span class="section">- RecyclerView</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<ul>
<li>5、侧边栏社交信息设置</li>
</ul>
<p>编辑主题配置文件_config.yml，修改social字段的值# Social Links</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value is the target link (E.g. GitHub: https://github.com/iissnan)</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#LinkLabel: Link</span></span><br><span class="line">  <span class="attr">Github:</span> <span class="string">https://github.com/yourgithub</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:dawnxu96@gmail.com</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourins</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>6、Hexo博客添加站内搜索</p>
<ul>
<li><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装。</p>
<ul>
<li><p>安装 hexo-generator-search</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编辑主题配置文件，设置local_searchenable为true</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四、个性化主题设置"><a href="#四、个性化主题设置" class="headerlink" title="四、个性化主题设置"></a>四、个性化主题设置</h3><p><a href="https://zhuanlan.zhihu.com/p/463229559">一个基础实用的参照链接（我参照的）</a><br><a href="https://zhuanlan.zhihu.com/p/28128674">一篇炫酷的页面设置指南（花里胡哨，操作比较费劲）</a><br><a href="https://zhuanlan.zhihu.com/p/85037898">比较基础（我参照的）</a></p>
<ul>
<li>1、首页中一篇文章显示太长，视觉上缩短一下</li>
</ul>
<p>方法一：打开文章的markdown文件，例如source&#x2F;_posts&#x2F;hello-world.md。<br>手动设置文章摘要，我们只需在想显示为摘要的内容之后添 <span id="more"></span> 即可。像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选取的文章摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">正文内容</span><br></pre></td></tr></table></figure>
<p>方法二：更优雅一些，而不是粗暴截断。即在写文章时，在元信息中指定摘要：description。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">点击阅读前文前,</span> <span class="string">首页能看到的文章的简短描述</span></span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、Hexo博客添加站内搜索</p>
<ul>
<li><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装。</p>
<ul>
<li><p>安装 hexo-generator-search</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编辑主题配置文件，设置local_searchenable为true</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3、美化页面布局<br>设置圆角<br><a href="https://zhuanlan.zhihu.com/p/252983030">参考网站</a><br><a href="https://zhuanlan.zhihu.com/p/280784973">参考网址2</a></p>
</li>
<li><p>4、查看下载了多少依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> --depth 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="npm-的使用"><a href="#npm-的使用" class="headerlink" title="npm 的使用"></a>npm 的使用</h3><h4 id="一、去官网安装最新的nodejs"><a href="#一、去官网安装最新的nodejs" class="headerlink" title="一、去官网安装最新的nodejs"></a>一、去官网安装最新的nodejs</h4><h4 id="二、更新npm"><a href="#二、更新npm" class="headerlink" title="二、更新npm"></a>二、更新npm</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm --不行就sudo权限</span><br><span class="line">npm view npm version --查看npm的版本</span><br></pre></td></tr></table></figure>
<h4 id="三、更新npm下的依赖"><a href="#三、更新npm下的依赖" class="headerlink" title="三、更新npm下的依赖"></a>三、更新npm下的依赖</h4><p><a href="https://www.npmjs.com/package/npm-check-updates">一个一把梭的官方指引</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br><span class="line">ncu  --Show all new dependencies (excluding peerDependencies) <span class="keyword">for</span> the project <span class="keyword">in</span> the current directory:</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
</search>
